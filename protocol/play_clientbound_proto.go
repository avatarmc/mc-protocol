// Generated by protocol_builder
// Do not edit

package protocol

import (
	"encoding/json"
	"fmt"
	"github.com/avatarmc/mc-protocol/encoding/nbt"
	"io"
	"io/ioutil"
	"math"
)

func (s *SpawnObject) id() int { return 0x00 }
func (s *SpawnObject) write(ww io.Writer) (err error) {
	var tmp [8]byte
	if err = WriteVarInt(ww, s.EntityID); err != nil {
		return
	}
	if err = s.UUID.Serialize(ww); err != nil {
		return
	}
	tmp[0] = byte(s.Type >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp0 := math.Float64bits(s.X)
	tmp[0] = byte(tmp0 >> 56)
	tmp[1] = byte(tmp0 >> 48)
	tmp[2] = byte(tmp0 >> 40)
	tmp[3] = byte(tmp0 >> 32)
	tmp[4] = byte(tmp0 >> 24)
	tmp[5] = byte(tmp0 >> 16)
	tmp[6] = byte(tmp0 >> 8)
	tmp[7] = byte(tmp0 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp1 := math.Float64bits(s.Y)
	tmp[0] = byte(tmp1 >> 56)
	tmp[1] = byte(tmp1 >> 48)
	tmp[2] = byte(tmp1 >> 40)
	tmp[3] = byte(tmp1 >> 32)
	tmp[4] = byte(tmp1 >> 24)
	tmp[5] = byte(tmp1 >> 16)
	tmp[6] = byte(tmp1 >> 8)
	tmp[7] = byte(tmp1 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp2 := math.Float64bits(s.Z)
	tmp[0] = byte(tmp2 >> 56)
	tmp[1] = byte(tmp2 >> 48)
	tmp[2] = byte(tmp2 >> 40)
	tmp[3] = byte(tmp2 >> 32)
	tmp[4] = byte(tmp2 >> 24)
	tmp[5] = byte(tmp2 >> 16)
	tmp[6] = byte(tmp2 >> 8)
	tmp[7] = byte(tmp2 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp[0] = byte(s.Pitch >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(s.Yaw >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(s.Data >> 24)
	tmp[1] = byte(s.Data >> 16)
	tmp[2] = byte(s.Data >> 8)
	tmp[3] = byte(s.Data >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(s.VelocityX >> 8)
	tmp[1] = byte(s.VelocityX >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	tmp[0] = byte(s.VelocityY >> 8)
	tmp[1] = byte(s.VelocityY >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	tmp[0] = byte(s.VelocityZ >> 8)
	tmp[1] = byte(s.VelocityZ >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	return
}
func (s *SpawnObject) read(rr io.Reader) (err error) {
	var tmp [8]byte
	if s.EntityID, err = ReadVarInt(rr); err != nil {
		return
	}
	if err = s.UUID.Deserialize(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	s.Type = (byte(tmp[0]) << 0)
	var tmp0 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp0 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	s.X = math.Float64frombits(tmp0)
	var tmp1 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp1 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	s.Y = math.Float64frombits(tmp1)
	var tmp2 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp2 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	s.Z = math.Float64frombits(tmp2)
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	s.Pitch = int8((uint8(tmp[0]) << 0))
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	s.Yaw = int8((uint8(tmp[0]) << 0))
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	s.Data = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	s.VelocityX = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	s.VelocityY = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	s.VelocityZ = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	return
}

func (s *SpawnExperienceOrb) id() int { return 0x01 }
func (s *SpawnExperienceOrb) write(ww io.Writer) (err error) {
	var tmp [8]byte
	if err = WriteVarInt(ww, s.EntityID); err != nil {
		return
	}
	tmp0 := math.Float64bits(s.X)
	tmp[0] = byte(tmp0 >> 56)
	tmp[1] = byte(tmp0 >> 48)
	tmp[2] = byte(tmp0 >> 40)
	tmp[3] = byte(tmp0 >> 32)
	tmp[4] = byte(tmp0 >> 24)
	tmp[5] = byte(tmp0 >> 16)
	tmp[6] = byte(tmp0 >> 8)
	tmp[7] = byte(tmp0 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp1 := math.Float64bits(s.Y)
	tmp[0] = byte(tmp1 >> 56)
	tmp[1] = byte(tmp1 >> 48)
	tmp[2] = byte(tmp1 >> 40)
	tmp[3] = byte(tmp1 >> 32)
	tmp[4] = byte(tmp1 >> 24)
	tmp[5] = byte(tmp1 >> 16)
	tmp[6] = byte(tmp1 >> 8)
	tmp[7] = byte(tmp1 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp2 := math.Float64bits(s.Z)
	tmp[0] = byte(tmp2 >> 56)
	tmp[1] = byte(tmp2 >> 48)
	tmp[2] = byte(tmp2 >> 40)
	tmp[3] = byte(tmp2 >> 32)
	tmp[4] = byte(tmp2 >> 24)
	tmp[5] = byte(tmp2 >> 16)
	tmp[6] = byte(tmp2 >> 8)
	tmp[7] = byte(tmp2 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp[0] = byte(s.Count >> 8)
	tmp[1] = byte(s.Count >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	return
}
func (s *SpawnExperienceOrb) read(rr io.Reader) (err error) {
	var tmp [8]byte
	if s.EntityID, err = ReadVarInt(rr); err != nil {
		return
	}
	var tmp0 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp0 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	s.X = math.Float64frombits(tmp0)
	var tmp1 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp1 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	s.Y = math.Float64frombits(tmp1)
	var tmp2 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp2 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	s.Z = math.Float64frombits(tmp2)
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	s.Count = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	return
}

func (s *SpawnGlobalEntity) id() int { return 0x02 }
func (s *SpawnGlobalEntity) write(ww io.Writer) (err error) {
	var tmp [8]byte
	if err = WriteVarInt(ww, s.EntityID); err != nil {
		return
	}
	tmp[0] = byte(s.Type >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp0 := math.Float64bits(s.X)
	tmp[0] = byte(tmp0 >> 56)
	tmp[1] = byte(tmp0 >> 48)
	tmp[2] = byte(tmp0 >> 40)
	tmp[3] = byte(tmp0 >> 32)
	tmp[4] = byte(tmp0 >> 24)
	tmp[5] = byte(tmp0 >> 16)
	tmp[6] = byte(tmp0 >> 8)
	tmp[7] = byte(tmp0 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp1 := math.Float64bits(s.Y)
	tmp[0] = byte(tmp1 >> 56)
	tmp[1] = byte(tmp1 >> 48)
	tmp[2] = byte(tmp1 >> 40)
	tmp[3] = byte(tmp1 >> 32)
	tmp[4] = byte(tmp1 >> 24)
	tmp[5] = byte(tmp1 >> 16)
	tmp[6] = byte(tmp1 >> 8)
	tmp[7] = byte(tmp1 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp2 := math.Float64bits(s.Z)
	tmp[0] = byte(tmp2 >> 56)
	tmp[1] = byte(tmp2 >> 48)
	tmp[2] = byte(tmp2 >> 40)
	tmp[3] = byte(tmp2 >> 32)
	tmp[4] = byte(tmp2 >> 24)
	tmp[5] = byte(tmp2 >> 16)
	tmp[6] = byte(tmp2 >> 8)
	tmp[7] = byte(tmp2 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	return
}
func (s *SpawnGlobalEntity) read(rr io.Reader) (err error) {
	var tmp [8]byte
	if s.EntityID, err = ReadVarInt(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	s.Type = (byte(tmp[0]) << 0)
	var tmp0 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp0 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	s.X = math.Float64frombits(tmp0)
	var tmp1 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp1 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	s.Y = math.Float64frombits(tmp1)
	var tmp2 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp2 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	s.Z = math.Float64frombits(tmp2)
	return
}

func (s *SpawnMob) id() int { return 0x03 }
func (s *SpawnMob) write(ww io.Writer) (err error) {
	var tmp [8]byte
	if err = WriteVarInt(ww, s.EntityID); err != nil {
		return
	}
	if err = s.UUID.Serialize(ww); err != nil {
		return
	}
	tmp[0] = byte(s.Type >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp0 := math.Float64bits(s.X)
	tmp[0] = byte(tmp0 >> 56)
	tmp[1] = byte(tmp0 >> 48)
	tmp[2] = byte(tmp0 >> 40)
	tmp[3] = byte(tmp0 >> 32)
	tmp[4] = byte(tmp0 >> 24)
	tmp[5] = byte(tmp0 >> 16)
	tmp[6] = byte(tmp0 >> 8)
	tmp[7] = byte(tmp0 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp1 := math.Float64bits(s.Y)
	tmp[0] = byte(tmp1 >> 56)
	tmp[1] = byte(tmp1 >> 48)
	tmp[2] = byte(tmp1 >> 40)
	tmp[3] = byte(tmp1 >> 32)
	tmp[4] = byte(tmp1 >> 24)
	tmp[5] = byte(tmp1 >> 16)
	tmp[6] = byte(tmp1 >> 8)
	tmp[7] = byte(tmp1 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp2 := math.Float64bits(s.Z)
	tmp[0] = byte(tmp2 >> 56)
	tmp[1] = byte(tmp2 >> 48)
	tmp[2] = byte(tmp2 >> 40)
	tmp[3] = byte(tmp2 >> 32)
	tmp[4] = byte(tmp2 >> 24)
	tmp[5] = byte(tmp2 >> 16)
	tmp[6] = byte(tmp2 >> 8)
	tmp[7] = byte(tmp2 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp[0] = byte(s.Yaw >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(s.Pitch >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(s.HeadPitch >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(s.VelocityX >> 8)
	tmp[1] = byte(s.VelocityX >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	tmp[0] = byte(s.VelocityY >> 8)
	tmp[1] = byte(s.VelocityY >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	tmp[0] = byte(s.VelocityZ >> 8)
	tmp[1] = byte(s.VelocityZ >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	if err = writeMetadata(ww, s.Metadata); err != nil {
		return
	}
	return
}
func (s *SpawnMob) read(rr io.Reader) (err error) {
	var tmp [8]byte
	if s.EntityID, err = ReadVarInt(rr); err != nil {
		return
	}
	if err = s.UUID.Deserialize(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	s.Type = (byte(tmp[0]) << 0)
	var tmp0 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp0 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	s.X = math.Float64frombits(tmp0)
	var tmp1 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp1 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	s.Y = math.Float64frombits(tmp1)
	var tmp2 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp2 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	s.Z = math.Float64frombits(tmp2)
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	s.Yaw = int8((uint8(tmp[0]) << 0))
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	s.Pitch = int8((uint8(tmp[0]) << 0))
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	s.HeadPitch = int8((uint8(tmp[0]) << 0))
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	s.VelocityX = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	s.VelocityY = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	s.VelocityZ = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	if s.Metadata, err = readMetadata(rr); err != nil {
		return
	}
	return
}

func (s *SpawnPainting) id() int { return 0x04 }
func (s *SpawnPainting) write(ww io.Writer) (err error) {
	var tmp [8]byte
	if err = WriteVarInt(ww, s.EntityID); err != nil {
		return
	}
	if err = s.UUID.Serialize(ww); err != nil {
		return
	}
	if err = WriteString(ww, s.Title); err != nil {
		return
	}
	tmp[0] = byte(s.Location >> 56)
	tmp[1] = byte(s.Location >> 48)
	tmp[2] = byte(s.Location >> 40)
	tmp[3] = byte(s.Location >> 32)
	tmp[4] = byte(s.Location >> 24)
	tmp[5] = byte(s.Location >> 16)
	tmp[6] = byte(s.Location >> 8)
	tmp[7] = byte(s.Location >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp[0] = byte(s.Direction >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	return
}
func (s *SpawnPainting) read(rr io.Reader) (err error) {
	var tmp [8]byte
	if s.EntityID, err = ReadVarInt(rr); err != nil {
		return
	}
	if err = s.UUID.Deserialize(rr); err != nil {
		return
	}
	if s.Title, err = ReadString(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	s.Location = (Position(tmp[7]) << 0) | (Position(tmp[6]) << 8) | (Position(tmp[5]) << 16) | (Position(tmp[4]) << 24) | (Position(tmp[3]) << 32) | (Position(tmp[2]) << 40) | (Position(tmp[1]) << 48) | (Position(tmp[0]) << 56)
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	s.Direction = (byte(tmp[0]) << 0)
	return
}

func (s *SpawnPlayer) id() int { return 0x05 }
func (s *SpawnPlayer) write(ww io.Writer) (err error) {
	var tmp [8]byte
	if err = WriteVarInt(ww, s.EntityID); err != nil {
		return
	}
	if err = s.UUID.Serialize(ww); err != nil {
		return
	}
	tmp0 := math.Float64bits(s.X)
	tmp[0] = byte(tmp0 >> 56)
	tmp[1] = byte(tmp0 >> 48)
	tmp[2] = byte(tmp0 >> 40)
	tmp[3] = byte(tmp0 >> 32)
	tmp[4] = byte(tmp0 >> 24)
	tmp[5] = byte(tmp0 >> 16)
	tmp[6] = byte(tmp0 >> 8)
	tmp[7] = byte(tmp0 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp1 := math.Float64bits(s.Y)
	tmp[0] = byte(tmp1 >> 56)
	tmp[1] = byte(tmp1 >> 48)
	tmp[2] = byte(tmp1 >> 40)
	tmp[3] = byte(tmp1 >> 32)
	tmp[4] = byte(tmp1 >> 24)
	tmp[5] = byte(tmp1 >> 16)
	tmp[6] = byte(tmp1 >> 8)
	tmp[7] = byte(tmp1 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp2 := math.Float64bits(s.Z)
	tmp[0] = byte(tmp2 >> 56)
	tmp[1] = byte(tmp2 >> 48)
	tmp[2] = byte(tmp2 >> 40)
	tmp[3] = byte(tmp2 >> 32)
	tmp[4] = byte(tmp2 >> 24)
	tmp[5] = byte(tmp2 >> 16)
	tmp[6] = byte(tmp2 >> 8)
	tmp[7] = byte(tmp2 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp[0] = byte(s.Yaw >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(s.Pitch >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if err = writeMetadata(ww, s.Metadata); err != nil {
		return
	}
	return
}
func (s *SpawnPlayer) read(rr io.Reader) (err error) {
	var tmp [8]byte
	if s.EntityID, err = ReadVarInt(rr); err != nil {
		return
	}
	if err = s.UUID.Deserialize(rr); err != nil {
		return
	}
	var tmp0 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp0 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	s.X = math.Float64frombits(tmp0)
	var tmp1 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp1 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	s.Y = math.Float64frombits(tmp1)
	var tmp2 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp2 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	s.Z = math.Float64frombits(tmp2)
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	s.Yaw = int8((uint8(tmp[0]) << 0))
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	s.Pitch = int8((uint8(tmp[0]) << 0))
	if s.Metadata, err = readMetadata(rr); err != nil {
		return
	}
	return
}

func (a *Animation) id() int { return 0x06 }
func (a *Animation) write(ww io.Writer) (err error) {
	var tmp [1]byte
	if err = WriteVarInt(ww, a.EntityID); err != nil {
		return
	}
	tmp[0] = byte(a.AnimationID >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	return
}
func (a *Animation) read(rr io.Reader) (err error) {
	var tmp [1]byte
	if a.EntityID, err = ReadVarInt(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	a.AnimationID = (byte(tmp[0]) << 0)
	return
}

func (s *Statistics) id() int { return 0x07 }
func (s *Statistics) write(ww io.Writer) (err error) {
	if err = WriteVarInt(ww, VarInt(len(s.Statistics))); err != nil {
		return
	}
	for tmp0 := range s.Statistics {
		if err = WriteString(ww, s.Statistics[tmp0].Name); err != nil {
			return
		}
		if err = WriteVarInt(ww, s.Statistics[tmp0].Value); err != nil {
			return
		}
	}
	return
}
func (s *Statistics) read(rr io.Reader) (err error) {
	var tmp0 VarInt
	if tmp0, err = ReadVarInt(rr); err != nil {
		return
	}
	if tmp0 > math.MaxInt16 {
		return fmt.Errorf("array larger than max value: %d > %d", tmp0, math.MaxInt16)
	}
	if tmp0 < 0 {
		return fmt.Errorf("negative array size: %d < 0", tmp0)
	}
	s.Statistics = make([]Statistic, tmp0)
	for tmp1 := range s.Statistics {
		if s.Statistics[tmp1].Name, err = ReadString(rr); err != nil {
			return
		}
		if s.Statistics[tmp1].Value, err = ReadVarInt(rr); err != nil {
			return
		}
	}
	return
}

func (b *BlockBreakAnimation) id() int { return 0x08 }
func (b *BlockBreakAnimation) write(ww io.Writer) (err error) {
	var tmp [8]byte
	if err = WriteVarInt(ww, b.EntityID); err != nil {
		return
	}
	tmp[0] = byte(b.Location >> 56)
	tmp[1] = byte(b.Location >> 48)
	tmp[2] = byte(b.Location >> 40)
	tmp[3] = byte(b.Location >> 32)
	tmp[4] = byte(b.Location >> 24)
	tmp[5] = byte(b.Location >> 16)
	tmp[6] = byte(b.Location >> 8)
	tmp[7] = byte(b.Location >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp[0] = byte(b.Stage >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	return
}
func (b *BlockBreakAnimation) read(rr io.Reader) (err error) {
	var tmp [8]byte
	if b.EntityID, err = ReadVarInt(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	b.Location = (Position(tmp[7]) << 0) | (Position(tmp[6]) << 8) | (Position(tmp[5]) << 16) | (Position(tmp[4]) << 24) | (Position(tmp[3]) << 32) | (Position(tmp[2]) << 40) | (Position(tmp[1]) << 48) | (Position(tmp[0]) << 56)
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	b.Stage = int8((uint8(tmp[0]) << 0))
	return
}

func (u *UpdateBlockEntity) id() int { return 0x09 }
func (u *UpdateBlockEntity) write(ww io.Writer) (err error) {
	var tmp [8]byte
	tmp[0] = byte(u.Location >> 56)
	tmp[1] = byte(u.Location >> 48)
	tmp[2] = byte(u.Location >> 40)
	tmp[3] = byte(u.Location >> 32)
	tmp[4] = byte(u.Location >> 24)
	tmp[5] = byte(u.Location >> 16)
	tmp[6] = byte(u.Location >> 8)
	tmp[7] = byte(u.Location >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp[0] = byte(u.Action >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if err = WriteNBT(ww, u.NBT); err != nil {
		return
	}
	return
}
func (u *UpdateBlockEntity) read(rr io.Reader) (err error) {
	var tmp [8]byte
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	u.Location = (Position(tmp[7]) << 0) | (Position(tmp[6]) << 8) | (Position(tmp[5]) << 16) | (Position(tmp[4]) << 24) | (Position(tmp[3]) << 32) | (Position(tmp[2]) << 40) | (Position(tmp[1]) << 48) | (Position(tmp[0]) << 56)
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	u.Action = (byte(tmp[0]) << 0)
	if u.NBT, err = ReadNBT(rr); err != nil {
		return
	}
	return
}

func (b *BlockAction) id() int { return 0x0A }
func (b *BlockAction) write(ww io.Writer) (err error) {
	var tmp [8]byte
	tmp[0] = byte(b.Location >> 56)
	tmp[1] = byte(b.Location >> 48)
	tmp[2] = byte(b.Location >> 40)
	tmp[3] = byte(b.Location >> 32)
	tmp[4] = byte(b.Location >> 24)
	tmp[5] = byte(b.Location >> 16)
	tmp[6] = byte(b.Location >> 8)
	tmp[7] = byte(b.Location >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp[0] = byte(b.Byte1 >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(b.Byte2 >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if err = WriteVarInt(ww, b.BlockType); err != nil {
		return
	}
	return
}
func (b *BlockAction) read(rr io.Reader) (err error) {
	var tmp [8]byte
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	b.Location = (Position(tmp[7]) << 0) | (Position(tmp[6]) << 8) | (Position(tmp[5]) << 16) | (Position(tmp[4]) << 24) | (Position(tmp[3]) << 32) | (Position(tmp[2]) << 40) | (Position(tmp[1]) << 48) | (Position(tmp[0]) << 56)
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	b.Byte1 = (byte(tmp[0]) << 0)
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	b.Byte2 = (byte(tmp[0]) << 0)
	if b.BlockType, err = ReadVarInt(rr); err != nil {
		return
	}
	return
}

func (b *BlockChange) id() int { return 0x0B }
func (b *BlockChange) write(ww io.Writer) (err error) {
	var tmp [8]byte
	tmp[0] = byte(b.Location >> 56)
	tmp[1] = byte(b.Location >> 48)
	tmp[2] = byte(b.Location >> 40)
	tmp[3] = byte(b.Location >> 32)
	tmp[4] = byte(b.Location >> 24)
	tmp[5] = byte(b.Location >> 16)
	tmp[6] = byte(b.Location >> 8)
	tmp[7] = byte(b.Location >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	if err = WriteVarInt(ww, b.BlockID); err != nil {
		return
	}
	return
}
func (b *BlockChange) read(rr io.Reader) (err error) {
	var tmp [8]byte
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	b.Location = (Position(tmp[7]) << 0) | (Position(tmp[6]) << 8) | (Position(tmp[5]) << 16) | (Position(tmp[4]) << 24) | (Position(tmp[3]) << 32) | (Position(tmp[2]) << 40) | (Position(tmp[1]) << 48) | (Position(tmp[0]) << 56)
	if b.BlockID, err = ReadVarInt(rr); err != nil {
		return
	}
	return
}

func (b *BossBar) id() int { return 0x0C }
func (b *BossBar) write(ww io.Writer) (err error) {
	var tmp [4]byte
	if err = b.UUID.Serialize(ww); err != nil {
		return
	}
	if err = WriteVarInt(ww, b.Action); err != nil {
		return
	}
	if b.Action == 0 || b.Action == 3 {
		var tmp0 []byte
		if tmp0, err = json.Marshal(&b.Title); err != nil {
			return
		}
		tmp1 := string(tmp0)
		if err = WriteString(ww, tmp1); err != nil {
			return
		}
	}
	if b.Action == 0 || b.Action == 2 {
		tmp2 := math.Float32bits(b.Health)
		tmp[0] = byte(tmp2 >> 24)
		tmp[1] = byte(tmp2 >> 16)
		tmp[2] = byte(tmp2 >> 8)
		tmp[3] = byte(tmp2 >> 0)
		if _, err = ww.Write(tmp[:4]); err != nil {
			return
		}
	}
	if b.Action == 0 || b.Action == 4 {
		if err = WriteVarInt(ww, b.Color); err != nil {
			return
		}
		if err = WriteVarInt(ww, b.Style); err != nil {
			return
		}
	}
	if b.Action == 0 || b.Action == 5 {
		tmp[0] = byte(b.Flags >> 0)
		if _, err = ww.Write(tmp[:1]); err != nil {
			return
		}
	}
	return
}
func (b *BossBar) read(rr io.Reader) (err error) {
	var tmp [4]byte
	if err = b.UUID.Deserialize(rr); err != nil {
		return
	}
	if b.Action, err = ReadVarInt(rr); err != nil {
		return
	}
	if b.Action == 0 || b.Action == 3 {
		var tmp0 string
		if tmp0, err = ReadString(rr); err != nil {
			return err
		}
		if err = json.Unmarshal([]byte(tmp0), &b.Title); err != nil {
			return
		}
	}
	if b.Action == 0 || b.Action == 2 {
		var tmp1 uint32
		if _, err = rr.Read(tmp[:4]); err != nil {
			return
		}
		tmp1 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
		b.Health = math.Float32frombits(tmp1)
	}
	if b.Action == 0 || b.Action == 4 {
		if b.Color, err = ReadVarInt(rr); err != nil {
			return
		}
		if b.Style, err = ReadVarInt(rr); err != nil {
			return
		}
	}
	if b.Action == 0 || b.Action == 5 {
		if _, err = rr.Read(tmp[:1]); err != nil {
			return
		}
		b.Flags = (byte(tmp[0]) << 0)
	}
	return
}

func (s *ServerDifficulty) id() int { return 0x0D }
func (s *ServerDifficulty) write(ww io.Writer) (err error) {
	var tmp [1]byte
	tmp[0] = byte(s.Difficulty >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	return
}
func (s *ServerDifficulty) read(rr io.Reader) (err error) {
	var tmp [1]byte
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	s.Difficulty = (byte(tmp[0]) << 0)
	return
}

func (t *TabCompleteReply) id() int { return 0x0E }
func (t *TabCompleteReply) write(ww io.Writer) (err error) {
	if err = WriteVarInt(ww, VarInt(len(t.Matches))); err != nil {
		return
	}
	for tmp0 := range t.Matches {
		if err = WriteString(ww, t.Matches[tmp0]); err != nil {
			return
		}
	}
	return
}
func (t *TabCompleteReply) read(rr io.Reader) (err error) {
	var tmp0 VarInt
	if tmp0, err = ReadVarInt(rr); err != nil {
		return
	}
	if tmp0 > math.MaxInt16 {
		return fmt.Errorf("array larger than max value: %d > %d", tmp0, math.MaxInt16)
	}
	if tmp0 < 0 {
		return fmt.Errorf("negative array size: %d < 0", tmp0)
	}
	t.Matches = make([]string, tmp0)
	for tmp1 := range t.Matches {
		if t.Matches[tmp1], err = ReadString(rr); err != nil {
			return
		}
	}
	return
}

func (s *ServerMessage) id() int { return 0x0F }
func (s *ServerMessage) write(ww io.Writer) (err error) {
	var tmp [1]byte
	var tmp0 []byte
	if tmp0, err = json.Marshal(&s.Message); err != nil {
		return
	}
	tmp1 := string(tmp0)
	if err = WriteString(ww, tmp1); err != nil {
		return
	}
	tmp[0] = byte(s.Type >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	return
}
func (s *ServerMessage) read(rr io.Reader) (err error) {
	var tmp [1]byte
	var tmp0 string
	if tmp0, err = ReadString(rr); err != nil {
		return err
	}
	if err = json.Unmarshal([]byte(tmp0), &s.Message); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	s.Type = (byte(tmp[0]) << 0)
	return
}

func (m *MultiBlockChange) id() int { return 0x10 }
func (m *MultiBlockChange) write(ww io.Writer) (err error) {
	var tmp [4]byte
	tmp[0] = byte(m.ChunkX >> 24)
	tmp[1] = byte(m.ChunkX >> 16)
	tmp[2] = byte(m.ChunkX >> 8)
	tmp[3] = byte(m.ChunkX >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(m.ChunkZ >> 24)
	tmp[1] = byte(m.ChunkZ >> 16)
	tmp[2] = byte(m.ChunkZ >> 8)
	tmp[3] = byte(m.ChunkZ >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	if err = WriteVarInt(ww, VarInt(len(m.Records))); err != nil {
		return
	}
	for tmp0 := range m.Records {
		tmp[0] = byte(m.Records[tmp0].XZ >> 0)
		if _, err = ww.Write(tmp[:1]); err != nil {
			return
		}
		tmp[0] = byte(m.Records[tmp0].Y >> 0)
		if _, err = ww.Write(tmp[:1]); err != nil {
			return
		}
		if err = WriteVarInt(ww, m.Records[tmp0].BlockID); err != nil {
			return
		}
	}
	return
}
func (m *MultiBlockChange) read(rr io.Reader) (err error) {
	var tmp [4]byte
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	m.ChunkX = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	m.ChunkZ = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	var tmp0 VarInt
	if tmp0, err = ReadVarInt(rr); err != nil {
		return
	}
	if tmp0 > math.MaxInt16 {
		return fmt.Errorf("array larger than max value: %d > %d", tmp0, math.MaxInt16)
	}
	if tmp0 < 0 {
		return fmt.Errorf("negative array size: %d < 0", tmp0)
	}
	m.Records = make([]BlockChangeRecord, tmp0)
	for tmp1 := range m.Records {
		if _, err = rr.Read(tmp[:1]); err != nil {
			return
		}
		m.Records[tmp1].XZ = (byte(tmp[0]) << 0)
		if _, err = rr.Read(tmp[:1]); err != nil {
			return
		}
		m.Records[tmp1].Y = (byte(tmp[0]) << 0)
		if m.Records[tmp1].BlockID, err = ReadVarInt(rr); err != nil {
			return
		}
	}
	return
}

func (c *ConfirmTransaction) id() int { return 0x11 }
func (c *ConfirmTransaction) write(ww io.Writer) (err error) {
	var tmp [2]byte
	tmp[0] = byte(c.ID >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(c.ActionNumber >> 8)
	tmp[1] = byte(c.ActionNumber >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	if err = WriteBool(ww, c.Accepted); err != nil {
		return
	}
	return
}
func (c *ConfirmTransaction) read(rr io.Reader) (err error) {
	var tmp [2]byte
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	c.ID = (byte(tmp[0]) << 0)
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	c.ActionNumber = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	if c.Accepted, err = ReadBool(rr); err != nil {
		return
	}
	return
}

func (w *WindowClose) id() int { return 0x12 }
func (w *WindowClose) write(ww io.Writer) (err error) {
	var tmp [1]byte
	tmp[0] = byte(w.ID >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	return
}
func (w *WindowClose) read(rr io.Reader) (err error) {
	var tmp [1]byte
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	w.ID = (byte(tmp[0]) << 0)
	return
}

func (w *WindowOpen) id() int { return 0x13 }
func (w *WindowOpen) write(ww io.Writer) (err error) {
	var tmp [4]byte
	tmp[0] = byte(w.ID >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if err = WriteString(ww, w.Type); err != nil {
		return
	}
	var tmp0 []byte
	if tmp0, err = json.Marshal(&w.Title); err != nil {
		return
	}
	tmp1 := string(tmp0)
	if err = WriteString(ww, tmp1); err != nil {
		return
	}
	tmp[0] = byte(w.SlotCount >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if w.Type == "EntityHorse" {
		tmp[0] = byte(w.EntityID >> 24)
		tmp[1] = byte(w.EntityID >> 16)
		tmp[2] = byte(w.EntityID >> 8)
		tmp[3] = byte(w.EntityID >> 0)
		if _, err = ww.Write(tmp[:4]); err != nil {
			return
		}
	}
	return
}
func (w *WindowOpen) read(rr io.Reader) (err error) {
	var tmp [4]byte
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	w.ID = (byte(tmp[0]) << 0)
	if w.Type, err = ReadString(rr); err != nil {
		return
	}
	var tmp0 string
	if tmp0, err = ReadString(rr); err != nil {
		return err
	}
	if err = json.Unmarshal([]byte(tmp0), &w.Title); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	w.SlotCount = (byte(tmp[0]) << 0)
	if w.Type == "EntityHorse" {
		if _, err = rr.Read(tmp[:4]); err != nil {
			return
		}
		w.EntityID = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	}
	return
}

func (w *WindowItems) id() int { return 0x14 }
func (w *WindowItems) write(ww io.Writer) (err error) {
	var tmp [2]byte
	tmp[0] = byte(w.ID >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(int16(len(w.Items)) >> 8)
	tmp[1] = byte(int16(len(w.Items)) >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	for tmp0 := range w.Items {
		if err = w.Items[tmp0].Serialize(ww); err != nil {
			return
		}
	}
	return
}
func (w *WindowItems) read(rr io.Reader) (err error) {
	var tmp [2]byte
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	w.ID = (byte(tmp[0]) << 0)
	var tmp0 int16
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	tmp0 = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	if tmp0 > math.MaxInt16 {
		return fmt.Errorf("array larger than max value: %d > %d", tmp0, math.MaxInt16)
	}
	if tmp0 < 0 {
		return fmt.Errorf("negative array size: %d < 0", tmp0)
	}
	w.Items = make([]ItemStack, tmp0)
	for tmp1 := range w.Items {
		if err = w.Items[tmp1].Deserialize(rr); err != nil {
			return
		}
	}
	return
}

func (w *WindowProperty) id() int { return 0x15 }
func (w *WindowProperty) write(ww io.Writer) (err error) {
	var tmp [2]byte
	tmp[0] = byte(w.ID >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(w.Property >> 8)
	tmp[1] = byte(w.Property >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	tmp[0] = byte(w.Value >> 8)
	tmp[1] = byte(w.Value >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	return
}
func (w *WindowProperty) read(rr io.Reader) (err error) {
	var tmp [2]byte
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	w.ID = (byte(tmp[0]) << 0)
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	w.Property = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	w.Value = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	return
}

func (w *WindowSetSlot) id() int { return 0x16 }
func (w *WindowSetSlot) write(ww io.Writer) (err error) {
	var tmp [2]byte
	tmp[0] = byte(w.ID >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(w.Slot >> 8)
	tmp[1] = byte(w.Slot >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	if err = w.ItemStack.Serialize(ww); err != nil {
		return
	}
	return
}
func (w *WindowSetSlot) read(rr io.Reader) (err error) {
	var tmp [2]byte
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	w.ID = (byte(tmp[0]) << 0)
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	w.Slot = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	if err = w.ItemStack.Deserialize(rr); err != nil {
		return
	}
	return
}

func (s *SetCooldown) id() int { return 0x17 }
func (s *SetCooldown) write(ww io.Writer) (err error) {
	if err = WriteVarInt(ww, s.ItemID); err != nil {
		return
	}
	if err = WriteVarInt(ww, s.Ticks); err != nil {
		return
	}
	return
}
func (s *SetCooldown) read(rr io.Reader) (err error) {
	if s.ItemID, err = ReadVarInt(rr); err != nil {
		return
	}
	if s.Ticks, err = ReadVarInt(rr); err != nil {
		return
	}
	return
}

func (p *PluginMessageClientbound) id() int { return 0x18 }
func (p *PluginMessageClientbound) write(ww io.Writer) (err error) {
	if err = WriteString(ww, p.Channel); err != nil {
		return
	}
	if _, err = ww.Write(p.Data); err != nil {
		return
	}
	return
}
func (p *PluginMessageClientbound) read(rr io.Reader) (err error) {
	if p.Channel, err = ReadString(rr); err != nil {
		return
	}
	if p.Data, err = ioutil.ReadAll(rr); err != nil {
		return
	}
	return
}

func (n *NamedSoundEffect) id() int { return 0x19 }
func (n *NamedSoundEffect) write(ww io.Writer) (err error) {
	var tmp [4]byte
	if err = WriteString(ww, n.Sound); err != nil {
		return
	}
	if err = WriteVarInt(ww, n.SoundCategory); err != nil {
		return
	}
	tmp[0] = byte(n.X >> 24)
	tmp[1] = byte(n.X >> 16)
	tmp[2] = byte(n.X >> 8)
	tmp[3] = byte(n.X >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(n.Y >> 24)
	tmp[1] = byte(n.Y >> 16)
	tmp[2] = byte(n.Y >> 8)
	tmp[3] = byte(n.Y >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(n.Z >> 24)
	tmp[1] = byte(n.Z >> 16)
	tmp[2] = byte(n.Z >> 8)
	tmp[3] = byte(n.Z >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp0 := math.Float32bits(n.Volume)
	tmp[0] = byte(tmp0 >> 24)
	tmp[1] = byte(tmp0 >> 16)
	tmp[2] = byte(tmp0 >> 8)
	tmp[3] = byte(tmp0 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp1 := math.Float32bits(n.Pitch)
	tmp[0] = byte(tmp1 >> 24)
	tmp[1] = byte(tmp1 >> 16)
	tmp[2] = byte(tmp1 >> 8)
	tmp[3] = byte(tmp1 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	return
}
func (n *NamedSoundEffect) read(rr io.Reader) (err error) {
	var tmp [4]byte
	if n.Sound, err = ReadString(rr); err != nil {
		return
	}
	if n.SoundCategory, err = ReadVarInt(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	n.X = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	n.Y = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	n.Z = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	var tmp0 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp0 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	n.Volume = math.Float32frombits(tmp0)
	var tmp1 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp1 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	n.Pitch = math.Float32frombits(tmp1)
	return
}

func (d *Disconnect) id() int { return 0x1A }
func (d *Disconnect) write(ww io.Writer) (err error) {
	var tmp0 []byte
	if tmp0, err = json.Marshal(&d.Reason); err != nil {
		return
	}
	tmp1 := string(tmp0)
	if err = WriteString(ww, tmp1); err != nil {
		return
	}
	return
}
func (d *Disconnect) read(rr io.Reader) (err error) {
	var tmp0 string
	if tmp0, err = ReadString(rr); err != nil {
		return err
	}
	if err = json.Unmarshal([]byte(tmp0), &d.Reason); err != nil {
		return
	}
	return
}

func (e *EntityAction) id() int { return 0x1B }
func (e *EntityAction) write(ww io.Writer) (err error) {
	var tmp [4]byte
	tmp[0] = byte(e.EntityID >> 24)
	tmp[1] = byte(e.EntityID >> 16)
	tmp[2] = byte(e.EntityID >> 8)
	tmp[3] = byte(e.EntityID >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(e.ActionID >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	return
}
func (e *EntityAction) read(rr io.Reader) (err error) {
	var tmp [4]byte
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	e.EntityID = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	e.ActionID = (byte(tmp[0]) << 0)
	return
}

func (e *Explosion) id() int { return 0x1C }
func (e *Explosion) write(ww io.Writer) (err error) {
	var tmp [4]byte
	tmp0 := math.Float32bits(e.X)
	tmp[0] = byte(tmp0 >> 24)
	tmp[1] = byte(tmp0 >> 16)
	tmp[2] = byte(tmp0 >> 8)
	tmp[3] = byte(tmp0 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp1 := math.Float32bits(e.Y)
	tmp[0] = byte(tmp1 >> 24)
	tmp[1] = byte(tmp1 >> 16)
	tmp[2] = byte(tmp1 >> 8)
	tmp[3] = byte(tmp1 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp2 := math.Float32bits(e.Z)
	tmp[0] = byte(tmp2 >> 24)
	tmp[1] = byte(tmp2 >> 16)
	tmp[2] = byte(tmp2 >> 8)
	tmp[3] = byte(tmp2 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp3 := math.Float32bits(e.Radius)
	tmp[0] = byte(tmp3 >> 24)
	tmp[1] = byte(tmp3 >> 16)
	tmp[2] = byte(tmp3 >> 8)
	tmp[3] = byte(tmp3 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(int32(len(e.Records)) >> 24)
	tmp[1] = byte(int32(len(e.Records)) >> 16)
	tmp[2] = byte(int32(len(e.Records)) >> 8)
	tmp[3] = byte(int32(len(e.Records)) >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	for tmp4 := range e.Records {
		tmp[0] = byte(e.Records[tmp4].X >> 0)
		if _, err = ww.Write(tmp[:1]); err != nil {
			return
		}
		tmp[0] = byte(e.Records[tmp4].Y >> 0)
		if _, err = ww.Write(tmp[:1]); err != nil {
			return
		}
		tmp[0] = byte(e.Records[tmp4].Z >> 0)
		if _, err = ww.Write(tmp[:1]); err != nil {
			return
		}
	}
	tmp5 := math.Float32bits(e.VelocityX)
	tmp[0] = byte(tmp5 >> 24)
	tmp[1] = byte(tmp5 >> 16)
	tmp[2] = byte(tmp5 >> 8)
	tmp[3] = byte(tmp5 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp6 := math.Float32bits(e.VelocityY)
	tmp[0] = byte(tmp6 >> 24)
	tmp[1] = byte(tmp6 >> 16)
	tmp[2] = byte(tmp6 >> 8)
	tmp[3] = byte(tmp6 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp7 := math.Float32bits(e.VelocityZ)
	tmp[0] = byte(tmp7 >> 24)
	tmp[1] = byte(tmp7 >> 16)
	tmp[2] = byte(tmp7 >> 8)
	tmp[3] = byte(tmp7 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	return
}
func (e *Explosion) read(rr io.Reader) (err error) {
	var tmp [4]byte
	var tmp0 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp0 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	e.X = math.Float32frombits(tmp0)
	var tmp1 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp1 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	e.Y = math.Float32frombits(tmp1)
	var tmp2 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp2 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	e.Z = math.Float32frombits(tmp2)
	var tmp3 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp3 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	e.Radius = math.Float32frombits(tmp3)
	var tmp4 int32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp4 = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if tmp4 > math.MaxInt16 {
		return fmt.Errorf("array larger than max value: %d > %d", tmp4, math.MaxInt16)
	}
	if tmp4 < 0 {
		return fmt.Errorf("negative array size: %d < 0", tmp4)
	}
	e.Records = make([]ExplosionRecord, tmp4)
	for tmp5 := range e.Records {
		if _, err = rr.Read(tmp[:1]); err != nil {
			return
		}
		e.Records[tmp5].X = int8((uint8(tmp[0]) << 0))
		if _, err = rr.Read(tmp[:1]); err != nil {
			return
		}
		e.Records[tmp5].Y = int8((uint8(tmp[0]) << 0))
		if _, err = rr.Read(tmp[:1]); err != nil {
			return
		}
		e.Records[tmp5].Z = int8((uint8(tmp[0]) << 0))
	}
	var tmp6 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp6 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	e.VelocityX = math.Float32frombits(tmp6)
	var tmp7 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp7 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	e.VelocityY = math.Float32frombits(tmp7)
	var tmp8 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp8 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	e.VelocityZ = math.Float32frombits(tmp8)
	return
}

func (c *ChunkUnload) id() int { return 0x1D }
func (c *ChunkUnload) write(ww io.Writer) (err error) {
	var tmp [4]byte
	tmp[0] = byte(c.X >> 24)
	tmp[1] = byte(c.X >> 16)
	tmp[2] = byte(c.X >> 8)
	tmp[3] = byte(c.X >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(c.Z >> 24)
	tmp[1] = byte(c.Z >> 16)
	tmp[2] = byte(c.Z >> 8)
	tmp[3] = byte(c.Z >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	return
}
func (c *ChunkUnload) read(rr io.Reader) (err error) {
	var tmp [4]byte
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	c.X = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	c.Z = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	return
}

func (c *ChangeGameState) id() int { return 0x1E }
func (c *ChangeGameState) write(ww io.Writer) (err error) {
	var tmp [4]byte
	tmp[0] = byte(c.Reason >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp0 := math.Float32bits(c.Value)
	tmp[0] = byte(tmp0 >> 24)
	tmp[1] = byte(tmp0 >> 16)
	tmp[2] = byte(tmp0 >> 8)
	tmp[3] = byte(tmp0 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	return
}
func (c *ChangeGameState) read(rr io.Reader) (err error) {
	var tmp [4]byte
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	c.Reason = (byte(tmp[0]) << 0)
	var tmp0 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp0 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	c.Value = math.Float32frombits(tmp0)
	return
}

func (k *KeepAliveClientbound) id() int { return 0x1F }
func (k *KeepAliveClientbound) write(ww io.Writer) (err error) {
	var tmp [8]byte
	tmp[0] = byte(k.ID >> 56)
	tmp[1] = byte(k.ID >> 48)
	tmp[2] = byte(k.ID >> 40)
	tmp[3] = byte(k.ID >> 32)
	tmp[4] = byte(k.ID >> 24)
	tmp[5] = byte(k.ID >> 16)
	tmp[6] = byte(k.ID >> 8)
	tmp[7] = byte(k.ID >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	return
}
func (k *KeepAliveClientbound) read(rr io.Reader) (err error) {
	var tmp [8]byte
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	k.ID = int64((uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56))
	return
}

func (c *ChunkData) id() int { return 0x20 }
func (c *ChunkData) write(ww io.Writer) (err error) {
	var tmp [4]byte
	tmp[0] = byte(c.ChunkX >> 24)
	tmp[1] = byte(c.ChunkX >> 16)
	tmp[2] = byte(c.ChunkX >> 8)
	tmp[3] = byte(c.ChunkX >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(c.ChunkZ >> 24)
	tmp[1] = byte(c.ChunkZ >> 16)
	tmp[2] = byte(c.ChunkZ >> 8)
	tmp[3] = byte(c.ChunkZ >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	if err = WriteBool(ww, c.New); err != nil {
		return
	}
	if err = WriteVarInt(ww, c.BitMask); err != nil {
		return
	}
	if err = WriteVarInt(ww, VarInt(len(c.Data))); err != nil {
		return
	}
	if _, err = ww.Write(c.Data); err != nil {
		return
	}
	if err = WriteVarInt(ww, VarInt(len(c.BlockEntities))); err != nil {
		return
	}
	for tmp0 := range c.BlockEntities {
		if err = WriteNBT(ww, c.BlockEntities[tmp0]); err != nil {
			return
		}
	}
	return
}
func (c *ChunkData) read(rr io.Reader) (err error) {
	var tmp [4]byte
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	c.ChunkX = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	c.ChunkZ = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if c.New, err = ReadBool(rr); err != nil {
		return
	}
	if c.BitMask, err = ReadVarInt(rr); err != nil {
		return
	}
	var tmp0 VarInt
	if tmp0, err = ReadVarInt(rr); err != nil {
		return
	}
	if tmp0 < 0 {
		return fmt.Errorf("negative array size: %d < 0", tmp0)
	}
	c.Data = make([]byte, tmp0)
	if _, err = rr.Read(c.Data); err != nil {
		return
	}
	var tmp1 VarInt
	if tmp1, err = ReadVarInt(rr); err != nil {
		return
	}
	if tmp1 < 0 {
		return fmt.Errorf("negative array size: %d < 0", tmp1)
	}
	c.BlockEntities = make([]*nbt.Compound, tmp1)
	for tmp2 := range c.BlockEntities {
		if c.BlockEntities[tmp2], err = ReadNBT(rr); err != nil {
			return
		}
	}
	return
}

func (e *Effect) id() int { return 0x21 }
func (e *Effect) write(ww io.Writer) (err error) {
	var tmp [8]byte
	tmp[0] = byte(e.EffectID >> 24)
	tmp[1] = byte(e.EffectID >> 16)
	tmp[2] = byte(e.EffectID >> 8)
	tmp[3] = byte(e.EffectID >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(e.Location >> 56)
	tmp[1] = byte(e.Location >> 48)
	tmp[2] = byte(e.Location >> 40)
	tmp[3] = byte(e.Location >> 32)
	tmp[4] = byte(e.Location >> 24)
	tmp[5] = byte(e.Location >> 16)
	tmp[6] = byte(e.Location >> 8)
	tmp[7] = byte(e.Location >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp[0] = byte(e.Data >> 24)
	tmp[1] = byte(e.Data >> 16)
	tmp[2] = byte(e.Data >> 8)
	tmp[3] = byte(e.Data >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	if err = WriteBool(ww, e.DisableRelative); err != nil {
		return
	}
	return
}
func (e *Effect) read(rr io.Reader) (err error) {
	var tmp [8]byte
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	e.EffectID = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	e.Location = (Position(tmp[7]) << 0) | (Position(tmp[6]) << 8) | (Position(tmp[5]) << 16) | (Position(tmp[4]) << 24) | (Position(tmp[3]) << 32) | (Position(tmp[2]) << 40) | (Position(tmp[1]) << 48) | (Position(tmp[0]) << 56)
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	e.Data = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if e.DisableRelative, err = ReadBool(rr); err != nil {
		return
	}
	return
}

func (p *Particle) id() int { return 0x22 }
func (p *Particle) write(ww io.Writer) (err error) {
	var tmp [4]byte
	tmp[0] = byte(p.ParticleID >> 24)
	tmp[1] = byte(p.ParticleID >> 16)
	tmp[2] = byte(p.ParticleID >> 8)
	tmp[3] = byte(p.ParticleID >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	if err = WriteBool(ww, p.LongDistance); err != nil {
		return
	}
	tmp0 := math.Float32bits(p.X)
	tmp[0] = byte(tmp0 >> 24)
	tmp[1] = byte(tmp0 >> 16)
	tmp[2] = byte(tmp0 >> 8)
	tmp[3] = byte(tmp0 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp1 := math.Float32bits(p.Y)
	tmp[0] = byte(tmp1 >> 24)
	tmp[1] = byte(tmp1 >> 16)
	tmp[2] = byte(tmp1 >> 8)
	tmp[3] = byte(tmp1 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp2 := math.Float32bits(p.Z)
	tmp[0] = byte(tmp2 >> 24)
	tmp[1] = byte(tmp2 >> 16)
	tmp[2] = byte(tmp2 >> 8)
	tmp[3] = byte(tmp2 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp3 := math.Float32bits(p.OffsetX)
	tmp[0] = byte(tmp3 >> 24)
	tmp[1] = byte(tmp3 >> 16)
	tmp[2] = byte(tmp3 >> 8)
	tmp[3] = byte(tmp3 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp4 := math.Float32bits(p.OffsetY)
	tmp[0] = byte(tmp4 >> 24)
	tmp[1] = byte(tmp4 >> 16)
	tmp[2] = byte(tmp4 >> 8)
	tmp[3] = byte(tmp4 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp5 := math.Float32bits(p.OffsetZ)
	tmp[0] = byte(tmp5 >> 24)
	tmp[1] = byte(tmp5 >> 16)
	tmp[2] = byte(tmp5 >> 8)
	tmp[3] = byte(tmp5 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp6 := math.Float32bits(p.Speed)
	tmp[0] = byte(tmp6 >> 24)
	tmp[1] = byte(tmp6 >> 16)
	tmp[2] = byte(tmp6 >> 8)
	tmp[3] = byte(tmp6 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(p.Count >> 24)
	tmp[1] = byte(p.Count >> 16)
	tmp[2] = byte(p.Count >> 8)
	tmp[3] = byte(p.Count >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	for tmp7 := range p.Data {
		if err = WriteVarInt(ww, p.Data[tmp7]); err != nil {
			return
		}
	}
	return
}
func (p *Particle) read(rr io.Reader) (err error) {
	var tmp [4]byte
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	p.ParticleID = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if p.LongDistance, err = ReadBool(rr); err != nil {
		return
	}
	var tmp0 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp0 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	p.X = math.Float32frombits(tmp0)
	var tmp1 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp1 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	p.Y = math.Float32frombits(tmp1)
	var tmp2 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp2 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	p.Z = math.Float32frombits(tmp2)
	var tmp3 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp3 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	p.OffsetX = math.Float32frombits(tmp3)
	var tmp4 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp4 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	p.OffsetY = math.Float32frombits(tmp4)
	var tmp5 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp5 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	p.OffsetZ = math.Float32frombits(tmp5)
	var tmp6 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp6 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	p.Speed = math.Float32frombits(tmp6)
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	p.Count = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	tmp7 := particleDataLength(p)
	if tmp7 > math.MaxInt16 {
		return fmt.Errorf("array larger than max value: %d > %d", tmp7, math.MaxInt16)
	}
	if tmp7 < 0 {
		return fmt.Errorf("negative array size: %d < 0", tmp7)
	}
	p.Data = make([]VarInt, tmp7)
	for tmp8 := range p.Data {
		if p.Data[tmp8], err = ReadVarInt(rr); err != nil {
			return
		}
	}
	return
}

func (j *JoinGame) id() int { return 0x23 }
func (j *JoinGame) write(ww io.Writer) (err error) {
	var tmp [4]byte
	tmp[0] = byte(j.EntityID >> 24)
	tmp[1] = byte(j.EntityID >> 16)
	tmp[2] = byte(j.EntityID >> 8)
	tmp[3] = byte(j.EntityID >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(j.Gamemode >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(j.Dimension >> 24)
	tmp[1] = byte(j.Dimension >> 16)
	tmp[2] = byte(j.Dimension >> 8)
	tmp[3] = byte(j.Dimension >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(j.Difficulty >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(j.MaxPlayers >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if err = WriteString(ww, j.LevelType); err != nil {
		return
	}
	if err = WriteBool(ww, j.ReducedDebugInfo); err != nil {
		return
	}
	return
}
func (j *JoinGame) read(rr io.Reader) (err error) {
	var tmp [4]byte
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	j.EntityID = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	j.Gamemode = (byte(tmp[0]) << 0)
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	j.Dimension = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	j.Difficulty = (byte(tmp[0]) << 0)
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	j.MaxPlayers = (byte(tmp[0]) << 0)
	if j.LevelType, err = ReadString(rr); err != nil {
		return
	}
	if j.ReducedDebugInfo, err = ReadBool(rr); err != nil {
		return
	}
	return
}

func (m *Maps) id() int { return 0x24 }
func (m *Maps) write(ww io.Writer) (err error) {
	var tmp [1]byte
	if err = WriteVarInt(ww, m.ItemDamage); err != nil {
		return
	}
	tmp[0] = byte(m.Scale >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if err = WriteBool(ww, m.TrackingPosition); err != nil {
		return
	}
	if err = WriteVarInt(ww, VarInt(len(m.Icons))); err != nil {
		return
	}
	for tmp0 := range m.Icons {
		tmp[0] = byte(m.Icons[tmp0].DirectionType >> 0)
		if _, err = ww.Write(tmp[:1]); err != nil {
			return
		}
		tmp[0] = byte(m.Icons[tmp0].X >> 0)
		if _, err = ww.Write(tmp[:1]); err != nil {
			return
		}
		tmp[0] = byte(m.Icons[tmp0].Z >> 0)
		if _, err = ww.Write(tmp[:1]); err != nil {
			return
		}
	}
	tmp[0] = byte(m.Columns >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if m.Columns > 0 {
		tmp[0] = byte(m.Rows >> 0)
		if _, err = ww.Write(tmp[:1]); err != nil {
			return
		}
		tmp[0] = byte(m.X >> 0)
		if _, err = ww.Write(tmp[:1]); err != nil {
			return
		}
		tmp[0] = byte(m.Z >> 0)
		if _, err = ww.Write(tmp[:1]); err != nil {
			return
		}
		if err = WriteVarInt(ww, VarInt(len(m.Data))); err != nil {
			return
		}
		if _, err = ww.Write(m.Data); err != nil {
			return
		}
	}
	return
}
func (m *Maps) read(rr io.Reader) (err error) {
	var tmp [1]byte
	if m.ItemDamage, err = ReadVarInt(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	m.Scale = int8((uint8(tmp[0]) << 0))
	if m.TrackingPosition, err = ReadBool(rr); err != nil {
		return
	}
	var tmp0 VarInt
	if tmp0, err = ReadVarInt(rr); err != nil {
		return
	}
	if tmp0 > math.MaxInt16 {
		return fmt.Errorf("array larger than max value: %d > %d", tmp0, math.MaxInt16)
	}
	if tmp0 < 0 {
		return fmt.Errorf("negative array size: %d < 0", tmp0)
	}
	m.Icons = make([]MapIcon, tmp0)
	for tmp1 := range m.Icons {
		if _, err = rr.Read(tmp[:1]); err != nil {
			return
		}
		m.Icons[tmp1].DirectionType = int8((uint8(tmp[0]) << 0))
		if _, err = rr.Read(tmp[:1]); err != nil {
			return
		}
		m.Icons[tmp1].X = int8((uint8(tmp[0]) << 0))
		if _, err = rr.Read(tmp[:1]); err != nil {
			return
		}
		m.Icons[tmp1].Z = int8((uint8(tmp[0]) << 0))
	}
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	m.Columns = (byte(tmp[0]) << 0)
	if m.Columns > 0 {
		if _, err = rr.Read(tmp[:1]); err != nil {
			return
		}
		m.Rows = (byte(tmp[0]) << 0)
		if _, err = rr.Read(tmp[:1]); err != nil {
			return
		}
		m.X = (byte(tmp[0]) << 0)
		if _, err = rr.Read(tmp[:1]); err != nil {
			return
		}
		m.Z = (byte(tmp[0]) << 0)
		var tmp2 VarInt
		if tmp2, err = ReadVarInt(rr); err != nil {
			return
		}
		if tmp2 > math.MaxInt16 {
			return fmt.Errorf("array larger than max value: %d > %d", tmp2, math.MaxInt16)
		}
		if tmp2 < 0 {
			return fmt.Errorf("negative array size: %d < 0", tmp2)
		}
		m.Data = make([]byte, tmp2)
		if _, err = rr.Read(m.Data); err != nil {
			return
		}
	}
	return
}

func (e *Entity) id() int { return 0x25 }
func (e *Entity) write(ww io.Writer) (err error) {
	if err = WriteVarInt(ww, e.EntityID); err != nil {
		return
	}
	return
}
func (e *Entity) read(rr io.Reader) (err error) {
	if e.EntityID, err = ReadVarInt(rr); err != nil {
		return
	}
	return
}

func (e *EntityMove) id() int { return 0x26 }
func (e *EntityMove) write(ww io.Writer) (err error) {
	var tmp [2]byte
	if err = WriteVarInt(ww, e.EntityID); err != nil {
		return
	}
	tmp[0] = byte(e.DeltaX >> 8)
	tmp[1] = byte(e.DeltaX >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	tmp[0] = byte(e.DeltaY >> 8)
	tmp[1] = byte(e.DeltaY >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	tmp[0] = byte(e.DeltaZ >> 8)
	tmp[1] = byte(e.DeltaZ >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	if err = WriteBool(ww, e.OnGround); err != nil {
		return
	}
	return
}
func (e *EntityMove) read(rr io.Reader) (err error) {
	var tmp [2]byte
	if e.EntityID, err = ReadVarInt(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	e.DeltaX = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	e.DeltaY = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	e.DeltaZ = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	if e.OnGround, err = ReadBool(rr); err != nil {
		return
	}
	return
}

func (e *EntityLookAndMove) id() int { return 0x27 }
func (e *EntityLookAndMove) write(ww io.Writer) (err error) {
	var tmp [2]byte
	if err = WriteVarInt(ww, e.EntityID); err != nil {
		return
	}
	tmp[0] = byte(e.DeltaX >> 8)
	tmp[1] = byte(e.DeltaX >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	tmp[0] = byte(e.DeltaY >> 8)
	tmp[1] = byte(e.DeltaY >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	tmp[0] = byte(e.DeltaZ >> 8)
	tmp[1] = byte(e.DeltaZ >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	tmp[0] = byte(e.Yaw >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(e.Pitch >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if err = WriteBool(ww, e.OnGround); err != nil {
		return
	}
	return
}
func (e *EntityLookAndMove) read(rr io.Reader) (err error) {
	var tmp [2]byte
	if e.EntityID, err = ReadVarInt(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	e.DeltaX = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	e.DeltaY = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	e.DeltaZ = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	e.Yaw = int8((uint8(tmp[0]) << 0))
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	e.Pitch = int8((uint8(tmp[0]) << 0))
	if e.OnGround, err = ReadBool(rr); err != nil {
		return
	}
	return
}

func (e *EntityLook) id() int { return 0x28 }
func (e *EntityLook) write(ww io.Writer) (err error) {
	var tmp [1]byte
	if err = WriteVarInt(ww, e.EntityID); err != nil {
		return
	}
	tmp[0] = byte(e.Yaw >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(e.Pitch >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if err = WriteBool(ww, e.OnGround); err != nil {
		return
	}
	return
}
func (e *EntityLook) read(rr io.Reader) (err error) {
	var tmp [1]byte
	if e.EntityID, err = ReadVarInt(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	e.Yaw = int8((uint8(tmp[0]) << 0))
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	e.Pitch = int8((uint8(tmp[0]) << 0))
	if e.OnGround, err = ReadBool(rr); err != nil {
		return
	}
	return
}

func (v *VebicleMoveClientbound) id() int { return 0x29 }
func (v *VebicleMoveClientbound) write(ww io.Writer) (err error) {
	var tmp [8]byte
	tmp0 := math.Float64bits(v.X)
	tmp[0] = byte(tmp0 >> 56)
	tmp[1] = byte(tmp0 >> 48)
	tmp[2] = byte(tmp0 >> 40)
	tmp[3] = byte(tmp0 >> 32)
	tmp[4] = byte(tmp0 >> 24)
	tmp[5] = byte(tmp0 >> 16)
	tmp[6] = byte(tmp0 >> 8)
	tmp[7] = byte(tmp0 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp1 := math.Float64bits(v.Y)
	tmp[0] = byte(tmp1 >> 56)
	tmp[1] = byte(tmp1 >> 48)
	tmp[2] = byte(tmp1 >> 40)
	tmp[3] = byte(tmp1 >> 32)
	tmp[4] = byte(tmp1 >> 24)
	tmp[5] = byte(tmp1 >> 16)
	tmp[6] = byte(tmp1 >> 8)
	tmp[7] = byte(tmp1 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp2 := math.Float64bits(v.Z)
	tmp[0] = byte(tmp2 >> 56)
	tmp[1] = byte(tmp2 >> 48)
	tmp[2] = byte(tmp2 >> 40)
	tmp[3] = byte(tmp2 >> 32)
	tmp[4] = byte(tmp2 >> 24)
	tmp[5] = byte(tmp2 >> 16)
	tmp[6] = byte(tmp2 >> 8)
	tmp[7] = byte(tmp2 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp3 := math.Float32bits(v.Yaw)
	tmp[0] = byte(tmp3 >> 24)
	tmp[1] = byte(tmp3 >> 16)
	tmp[2] = byte(tmp3 >> 8)
	tmp[3] = byte(tmp3 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp4 := math.Float32bits(v.Pitch)
	tmp[0] = byte(tmp4 >> 24)
	tmp[1] = byte(tmp4 >> 16)
	tmp[2] = byte(tmp4 >> 8)
	tmp[3] = byte(tmp4 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	return
}
func (v *VebicleMoveClientbound) read(rr io.Reader) (err error) {
	var tmp [8]byte
	var tmp0 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp0 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	v.X = math.Float64frombits(tmp0)
	var tmp1 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp1 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	v.Y = math.Float64frombits(tmp1)
	var tmp2 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp2 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	v.Z = math.Float64frombits(tmp2)
	var tmp3 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp3 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	v.Yaw = math.Float32frombits(tmp3)
	var tmp4 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp4 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	v.Pitch = math.Float32frombits(tmp4)
	return
}

func (s *SignEditorOpen) id() int { return 0x2A }
func (s *SignEditorOpen) write(ww io.Writer) (err error) {
	var tmp [8]byte
	tmp[0] = byte(s.Location >> 56)
	tmp[1] = byte(s.Location >> 48)
	tmp[2] = byte(s.Location >> 40)
	tmp[3] = byte(s.Location >> 32)
	tmp[4] = byte(s.Location >> 24)
	tmp[5] = byte(s.Location >> 16)
	tmp[6] = byte(s.Location >> 8)
	tmp[7] = byte(s.Location >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	return
}
func (s *SignEditorOpen) read(rr io.Reader) (err error) {
	var tmp [8]byte
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	s.Location = (Position(tmp[7]) << 0) | (Position(tmp[6]) << 8) | (Position(tmp[5]) << 16) | (Position(tmp[4]) << 24) | (Position(tmp[3]) << 32) | (Position(tmp[2]) << 40) | (Position(tmp[1]) << 48) | (Position(tmp[0]) << 56)
	return
}

func (c *CraftRecipeResponse) id() int { return 0x2B }
func (c *CraftRecipeResponse) write(ww io.Writer) (err error) {
	var tmp [1]byte
	tmp[0] = byte(c.WindowID >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if err = WriteVarInt(ww, c.Recipe); err != nil {
		return
	}
	return
}
func (c *CraftRecipeResponse) read(rr io.Reader) (err error) {
	var tmp [1]byte
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	c.WindowID = (byte(tmp[0]) << 0)
	if c.Recipe, err = ReadVarInt(rr); err != nil {
		return
	}
	return
}

func (p *PlayerAbilities) id() int { return 0x2C }
func (p *PlayerAbilities) write(ww io.Writer) (err error) {
	var tmp [4]byte
	tmp[0] = byte(p.Flags >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp0 := math.Float32bits(p.FlyingSpeed)
	tmp[0] = byte(tmp0 >> 24)
	tmp[1] = byte(tmp0 >> 16)
	tmp[2] = byte(tmp0 >> 8)
	tmp[3] = byte(tmp0 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp1 := math.Float32bits(p.WalkingSpeed)
	tmp[0] = byte(tmp1 >> 24)
	tmp[1] = byte(tmp1 >> 16)
	tmp[2] = byte(tmp1 >> 8)
	tmp[3] = byte(tmp1 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	return
}
func (p *PlayerAbilities) read(rr io.Reader) (err error) {
	var tmp [4]byte
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	p.Flags = (byte(tmp[0]) << 0)
	var tmp0 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp0 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	p.FlyingSpeed = math.Float32frombits(tmp0)
	var tmp1 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp1 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	p.WalkingSpeed = math.Float32frombits(tmp1)
	return
}

func (c *CombatEvent) id() int { return 0x2D }
func (c *CombatEvent) write(ww io.Writer) (err error) {
	var tmp [4]byte
	if err = WriteVarInt(ww, c.Event); err != nil {
		return
	}
	if c.Event == 1 {
		if err = WriteVarInt(ww, c.Duration); err != nil {
			return
		}
	}
	if c.Event == 2 {
		if err = WriteVarInt(ww, c.PlayerID); err != nil {
			return
		}
	}
	if c.Event == 1 || c.Event == 2 {
		tmp[0] = byte(c.EntityID >> 24)
		tmp[1] = byte(c.EntityID >> 16)
		tmp[2] = byte(c.EntityID >> 8)
		tmp[3] = byte(c.EntityID >> 0)
		if _, err = ww.Write(tmp[:4]); err != nil {
			return
		}
	}
	if c.Event == 2 {
		var tmp0 []byte
		if tmp0, err = json.Marshal(&c.Message); err != nil {
			return
		}
		tmp1 := string(tmp0)
		if err = WriteString(ww, tmp1); err != nil {
			return
		}
	}
	return
}
func (c *CombatEvent) read(rr io.Reader) (err error) {
	var tmp [4]byte
	if c.Event, err = ReadVarInt(rr); err != nil {
		return
	}
	if c.Event == 1 {
		if c.Duration, err = ReadVarInt(rr); err != nil {
			return
		}
	}
	if c.Event == 2 {
		if c.PlayerID, err = ReadVarInt(rr); err != nil {
			return
		}
	}
	if c.Event == 1 || c.Event == 2 {
		if _, err = rr.Read(tmp[:4]); err != nil {
			return
		}
		c.EntityID = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	}
	if c.Event == 2 {
		var tmp0 string
		if tmp0, err = ReadString(rr); err != nil {
			return err
		}
		if err = json.Unmarshal([]byte(tmp0), &c.Message); err != nil {
			return
		}
	}
	return
}

func (p *PlayerInfo) id() int { return 0x2E }
func (p *PlayerInfo) write(ww io.Writer) (err error) {
	if err = WriteVarInt(ww, p.Action); err != nil {
		return
	}
	if err = WriteVarInt(ww, VarInt(len(p.Players))); err != nil {
		return
	}
	for tmp0 := range p.Players {
		if err = p.Players[tmp0].UUID.Serialize(ww); err != nil {
			return
		}
		if p.Action == 0 {
			if err = WriteString(ww, p.Players[tmp0].Name); err != nil {
				return
			}
			if err = WriteVarInt(ww, VarInt(len(p.Players[tmp0].Properties))); err != nil {
				return
			}
			for tmp1 := range p.Players[tmp0].Properties {
				if err = WriteString(ww, p.Players[tmp0].Properties[tmp1].Name); err != nil {
					return
				}
				if err = WriteString(ww, p.Players[tmp0].Properties[tmp1].Value); err != nil {
					return
				}
				if err = WriteBool(ww, p.Players[tmp0].Properties[tmp1].IsSigned); err != nil {
					return
				}
				if p.Players[tmp0].Properties[tmp1].IsSigned == true {
					if err = WriteString(ww, p.Players[tmp0].Properties[tmp1].Signature); err != nil {
						return
					}
				}
			}
		}
		if p.Action == 0 || p.Action == 1 {
			if err = WriteVarInt(ww, p.Players[tmp0].GameMode); err != nil {
				return
			}
		}
		if p.Action == 0 || p.Action == 2 {
			if err = WriteVarInt(ww, p.Players[tmp0].Ping); err != nil {
				return
			}
		}
		if p.Action == 0 || p.Action == 3 {
			if err = WriteBool(ww, p.Players[tmp0].HasDisplay); err != nil {
				return
			}
		}
		if p.Players[tmp0].HasDisplay == true {
			var tmp2 []byte
			if tmp2, err = json.Marshal(&p.Players[tmp0].DisplayName); err != nil {
				return
			}
			tmp3 := string(tmp2)
			if err = WriteString(ww, tmp3); err != nil {
				return
			}
		}
	}
	return
}
func (p *PlayerInfo) read(rr io.Reader) (err error) {
	if p.Action, err = ReadVarInt(rr); err != nil {
		return
	}
	var tmp0 VarInt
	if tmp0, err = ReadVarInt(rr); err != nil {
		return
	}
	if tmp0 > math.MaxInt16 {
		return fmt.Errorf("array larger than max value: %d > %d", tmp0, math.MaxInt16)
	}
	if tmp0 < 0 {
		return fmt.Errorf("negative array size: %d < 0", tmp0)
	}
	p.Players = make([]PlayerDetail, tmp0)
	for tmp1 := range p.Players {
		if err = p.Players[tmp1].UUID.Deserialize(rr); err != nil {
			return
		}
		if p.Action == 0 {
			if p.Players[tmp1].Name, err = ReadString(rr); err != nil {
				return
			}
			var tmp2 VarInt
			if tmp2, err = ReadVarInt(rr); err != nil {
				return
			}
			if tmp2 > math.MaxInt16 {
				return fmt.Errorf("array larger than max value: %d > %d", tmp2, math.MaxInt16)
			}
			if tmp2 < 0 {
				return fmt.Errorf("negative array size: %d < 0", tmp2)
			}
			p.Players[tmp1].Properties = make([]PlayerProperty, tmp2)
			for tmp3 := range p.Players[tmp1].Properties {
				if p.Players[tmp1].Properties[tmp3].Name, err = ReadString(rr); err != nil {
					return
				}
				if p.Players[tmp1].Properties[tmp3].Value, err = ReadString(rr); err != nil {
					return
				}
				if p.Players[tmp1].Properties[tmp3].IsSigned, err = ReadBool(rr); err != nil {
					return
				}
				if p.Players[tmp1].Properties[tmp3].IsSigned == true {
					if p.Players[tmp1].Properties[tmp3].Signature, err = ReadString(rr); err != nil {
						return
					}
				}
			}
		}
		if p.Action == 0 || p.Action == 1 {
			if p.Players[tmp1].GameMode, err = ReadVarInt(rr); err != nil {
				return
			}
		}
		if p.Action == 0 || p.Action == 2 {
			if p.Players[tmp1].Ping, err = ReadVarInt(rr); err != nil {
				return
			}
		}
		if p.Action == 0 || p.Action == 3 {
			if p.Players[tmp1].HasDisplay, err = ReadBool(rr); err != nil {
				return
			}
		}
		if p.Players[tmp1].HasDisplay == true {
			var tmp4 string
			if tmp4, err = ReadString(rr); err != nil {
				return err
			}
			if err = json.Unmarshal([]byte(tmp4), &p.Players[tmp1].DisplayName); err != nil {
				return
			}
		}
	}
	return
}

func (t *TeleportPlayer) id() int { return 0x2F }
func (t *TeleportPlayer) write(ww io.Writer) (err error) {
	var tmp [8]byte
	tmp0 := math.Float64bits(t.X)
	tmp[0] = byte(tmp0 >> 56)
	tmp[1] = byte(tmp0 >> 48)
	tmp[2] = byte(tmp0 >> 40)
	tmp[3] = byte(tmp0 >> 32)
	tmp[4] = byte(tmp0 >> 24)
	tmp[5] = byte(tmp0 >> 16)
	tmp[6] = byte(tmp0 >> 8)
	tmp[7] = byte(tmp0 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp1 := math.Float64bits(t.Y)
	tmp[0] = byte(tmp1 >> 56)
	tmp[1] = byte(tmp1 >> 48)
	tmp[2] = byte(tmp1 >> 40)
	tmp[3] = byte(tmp1 >> 32)
	tmp[4] = byte(tmp1 >> 24)
	tmp[5] = byte(tmp1 >> 16)
	tmp[6] = byte(tmp1 >> 8)
	tmp[7] = byte(tmp1 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp2 := math.Float64bits(t.Z)
	tmp[0] = byte(tmp2 >> 56)
	tmp[1] = byte(tmp2 >> 48)
	tmp[2] = byte(tmp2 >> 40)
	tmp[3] = byte(tmp2 >> 32)
	tmp[4] = byte(tmp2 >> 24)
	tmp[5] = byte(tmp2 >> 16)
	tmp[6] = byte(tmp2 >> 8)
	tmp[7] = byte(tmp2 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp3 := math.Float32bits(t.Yaw)
	tmp[0] = byte(tmp3 >> 24)
	tmp[1] = byte(tmp3 >> 16)
	tmp[2] = byte(tmp3 >> 8)
	tmp[3] = byte(tmp3 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp4 := math.Float32bits(t.Pitch)
	tmp[0] = byte(tmp4 >> 24)
	tmp[1] = byte(tmp4 >> 16)
	tmp[2] = byte(tmp4 >> 8)
	tmp[3] = byte(tmp4 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(t.Flags >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if err = WriteVarInt(ww, t.TeleportID); err != nil {
		return
	}
	return
}
func (t *TeleportPlayer) read(rr io.Reader) (err error) {
	var tmp [8]byte
	var tmp0 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp0 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	t.X = math.Float64frombits(tmp0)
	var tmp1 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp1 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	t.Y = math.Float64frombits(tmp1)
	var tmp2 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp2 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	t.Z = math.Float64frombits(tmp2)
	var tmp3 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp3 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	t.Yaw = math.Float32frombits(tmp3)
	var tmp4 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp4 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	t.Pitch = math.Float32frombits(tmp4)
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	t.Flags = (byte(tmp[0]) << 0)
	if t.TeleportID, err = ReadVarInt(rr); err != nil {
		return
	}
	return
}

func (e *EntityUsedBed) id() int { return 0x30 }
func (e *EntityUsedBed) write(ww io.Writer) (err error) {
	var tmp [8]byte
	if err = WriteVarInt(ww, e.EntityID); err != nil {
		return
	}
	tmp[0] = byte(e.Location >> 56)
	tmp[1] = byte(e.Location >> 48)
	tmp[2] = byte(e.Location >> 40)
	tmp[3] = byte(e.Location >> 32)
	tmp[4] = byte(e.Location >> 24)
	tmp[5] = byte(e.Location >> 16)
	tmp[6] = byte(e.Location >> 8)
	tmp[7] = byte(e.Location >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	return
}
func (e *EntityUsedBed) read(rr io.Reader) (err error) {
	var tmp [8]byte
	if e.EntityID, err = ReadVarInt(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	e.Location = (Position(tmp[7]) << 0) | (Position(tmp[6]) << 8) | (Position(tmp[5]) << 16) | (Position(tmp[4]) << 24) | (Position(tmp[3]) << 32) | (Position(tmp[2]) << 40) | (Position(tmp[1]) << 48) | (Position(tmp[0]) << 56)
	return
}

func (u *UnlockRecipes) id() int { return 0x31 }
func (u *UnlockRecipes) write(ww io.Writer) (err error) {
	if err = WriteVarInt(ww, u.Action); err != nil {
		return
	}
	if err = WriteBool(ww, u.CraftingBookOpen); err != nil {
		return
	}
	if err = WriteBool(ww, u.FilteringCraftable); err != nil {
		return
	}
	if err = WriteVarInt(ww, VarInt(len(u.RecipeIDs))); err != nil {
		return
	}
	for tmp0 := range u.RecipeIDs {
		if err = WriteVarInt(ww, u.RecipeIDs[tmp0]); err != nil {
			return
		}
	}
	if err = WriteVarInt(ww, VarInt(len(u.RecipeIDs2))); err != nil {
		return
	}
	for tmp1 := range u.RecipeIDs2 {
		if err = WriteVarInt(ww, u.RecipeIDs2[tmp1]); err != nil {
			return
		}
	}
	return
}
func (u *UnlockRecipes) read(rr io.Reader) (err error) {
	if u.Action, err = ReadVarInt(rr); err != nil {
		return
	}
	if u.CraftingBookOpen, err = ReadBool(rr); err != nil {
		return
	}
	if u.FilteringCraftable, err = ReadBool(rr); err != nil {
		return
	}
	var tmp0 VarInt
	if tmp0, err = ReadVarInt(rr); err != nil {
		return
	}
	if tmp0 > math.MaxInt16 {
		return fmt.Errorf("array larger than max value: %d > %d", tmp0, math.MaxInt16)
	}
	if tmp0 < 0 {
		return fmt.Errorf("negative array size: %d < 0", tmp0)
	}
	u.RecipeIDs = make([]VarInt, tmp0)
	for tmp1 := range u.RecipeIDs {
		if u.RecipeIDs[tmp1], err = ReadVarInt(rr); err != nil {
			return
		}
	}
	var tmp2 VarInt
	if tmp2, err = ReadVarInt(rr); err != nil {
		return
	}
	if tmp2 > math.MaxInt16 {
		return fmt.Errorf("array larger than max value: %d > %d", tmp2, math.MaxInt16)
	}
	if tmp2 < 0 {
		return fmt.Errorf("negative array size: %d < 0", tmp2)
	}
	u.RecipeIDs2 = make([]VarInt, tmp2)
	for tmp3 := range u.RecipeIDs2 {
		if u.RecipeIDs2[tmp3], err = ReadVarInt(rr); err != nil {
			return
		}
	}
	return
}

func (e *EntityDestroy) id() int { return 0x32 }
func (e *EntityDestroy) write(ww io.Writer) (err error) {
	if err = WriteVarInt(ww, VarInt(len(e.EntityIDs))); err != nil {
		return
	}
	for tmp0 := range e.EntityIDs {
		if err = WriteVarInt(ww, e.EntityIDs[tmp0]); err != nil {
			return
		}
	}
	return
}
func (e *EntityDestroy) read(rr io.Reader) (err error) {
	var tmp0 VarInt
	if tmp0, err = ReadVarInt(rr); err != nil {
		return
	}
	if tmp0 > math.MaxInt16 {
		return fmt.Errorf("array larger than max value: %d > %d", tmp0, math.MaxInt16)
	}
	if tmp0 < 0 {
		return fmt.Errorf("negative array size: %d < 0", tmp0)
	}
	e.EntityIDs = make([]VarInt, tmp0)
	for tmp1 := range e.EntityIDs {
		if e.EntityIDs[tmp1], err = ReadVarInt(rr); err != nil {
			return
		}
	}
	return
}

func (e *EntityRemoveEffect) id() int { return 0x33 }
func (e *EntityRemoveEffect) write(ww io.Writer) (err error) {
	var tmp [1]byte
	if err = WriteVarInt(ww, e.EntityID); err != nil {
		return
	}
	tmp[0] = byte(e.EffectID >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	return
}
func (e *EntityRemoveEffect) read(rr io.Reader) (err error) {
	var tmp [1]byte
	if e.EntityID, err = ReadVarInt(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	e.EffectID = int8((uint8(tmp[0]) << 0))
	return
}

func (r *ResourcePackSend) id() int { return 0x34 }
func (r *ResourcePackSend) write(ww io.Writer) (err error) {
	if err = WriteString(ww, r.URL); err != nil {
		return
	}
	if err = WriteString(ww, r.Hash); err != nil {
		return
	}
	return
}
func (r *ResourcePackSend) read(rr io.Reader) (err error) {
	if r.URL, err = ReadString(rr); err != nil {
		return
	}
	if r.Hash, err = ReadString(rr); err != nil {
		return
	}
	return
}

func (r *Respawn) id() int { return 0x35 }
func (r *Respawn) write(ww io.Writer) (err error) {
	var tmp [4]byte
	tmp[0] = byte(r.Dimension >> 24)
	tmp[1] = byte(r.Dimension >> 16)
	tmp[2] = byte(r.Dimension >> 8)
	tmp[3] = byte(r.Dimension >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(r.Difficulty >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(r.Gamemode >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if err = WriteString(ww, r.LevelType); err != nil {
		return
	}
	return
}
func (r *Respawn) read(rr io.Reader) (err error) {
	var tmp [4]byte
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	r.Dimension = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	r.Difficulty = (byte(tmp[0]) << 0)
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	r.Gamemode = (byte(tmp[0]) << 0)
	if r.LevelType, err = ReadString(rr); err != nil {
		return
	}
	return
}

func (e *EntityHeadLook) id() int { return 0x36 }
func (e *EntityHeadLook) write(ww io.Writer) (err error) {
	var tmp [1]byte
	if err = WriteVarInt(ww, e.EntityID); err != nil {
		return
	}
	tmp[0] = byte(e.HeadYaw >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	return
}
func (e *EntityHeadLook) read(rr io.Reader) (err error) {
	var tmp [1]byte
	if e.EntityID, err = ReadVarInt(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	e.HeadYaw = int8((uint8(tmp[0]) << 0))
	return
}

func (s *SelectAdvancementTab) id() int { return 0x37 }
func (s *SelectAdvancementTab) write(ww io.Writer) (err error) {
	if err = WriteBool(ww, s.HasID); err != nil {
		return
	}
	if err = WriteString(ww, s.Tab); err != nil {
		return
	}
	return
}
func (s *SelectAdvancementTab) read(rr io.Reader) (err error) {
	if s.HasID, err = ReadBool(rr); err != nil {
		return
	}
	if s.Tab, err = ReadString(rr); err != nil {
		return
	}
	return
}

func (w *WorldBorder) id() int { return 0x38 }
func (w *WorldBorder) write(ww io.Writer) (err error) {
	var tmp [8]byte
	if err = WriteVarInt(ww, w.Action); err != nil {
		return
	}
	if w.Action == 3 || w.Action == 1 {
		tmp0 := math.Float64bits(w.OldRadius)
		tmp[0] = byte(tmp0 >> 56)
		tmp[1] = byte(tmp0 >> 48)
		tmp[2] = byte(tmp0 >> 40)
		tmp[3] = byte(tmp0 >> 32)
		tmp[4] = byte(tmp0 >> 24)
		tmp[5] = byte(tmp0 >> 16)
		tmp[6] = byte(tmp0 >> 8)
		tmp[7] = byte(tmp0 >> 0)
		if _, err = ww.Write(tmp[:8]); err != nil {
			return
		}
	}
	if w.Action == 3 || w.Action == 1 || w.Action == 0 {
		tmp1 := math.Float64bits(w.NewRadius)
		tmp[0] = byte(tmp1 >> 56)
		tmp[1] = byte(tmp1 >> 48)
		tmp[2] = byte(tmp1 >> 40)
		tmp[3] = byte(tmp1 >> 32)
		tmp[4] = byte(tmp1 >> 24)
		tmp[5] = byte(tmp1 >> 16)
		tmp[6] = byte(tmp1 >> 8)
		tmp[7] = byte(tmp1 >> 0)
		if _, err = ww.Write(tmp[:8]); err != nil {
			return
		}
	}
	if w.Action == 3 || w.Action == 1 {
		if err = WriteVarLong(ww, w.Speed); err != nil {
			return
		}
	}
	if w.Action == 3 || w.Action == 2 {
		tmp2 := math.Float64bits(w.X)
		tmp[0] = byte(tmp2 >> 56)
		tmp[1] = byte(tmp2 >> 48)
		tmp[2] = byte(tmp2 >> 40)
		tmp[3] = byte(tmp2 >> 32)
		tmp[4] = byte(tmp2 >> 24)
		tmp[5] = byte(tmp2 >> 16)
		tmp[6] = byte(tmp2 >> 8)
		tmp[7] = byte(tmp2 >> 0)
		if _, err = ww.Write(tmp[:8]); err != nil {
			return
		}
		tmp3 := math.Float64bits(w.Z)
		tmp[0] = byte(tmp3 >> 56)
		tmp[1] = byte(tmp3 >> 48)
		tmp[2] = byte(tmp3 >> 40)
		tmp[3] = byte(tmp3 >> 32)
		tmp[4] = byte(tmp3 >> 24)
		tmp[5] = byte(tmp3 >> 16)
		tmp[6] = byte(tmp3 >> 8)
		tmp[7] = byte(tmp3 >> 0)
		if _, err = ww.Write(tmp[:8]); err != nil {
			return
		}
	}
	if w.Action == 3 {
		if err = WriteVarInt(ww, w.PortalBoundary); err != nil {
			return
		}
	}
	if w.Action == 3 || w.Action == 4 {
		if err = WriteVarInt(ww, w.WarningTime); err != nil {
			return
		}
	}
	if w.Action == 3 || w.Action == 5 {
		if err = WriteVarInt(ww, w.WarningBlocks); err != nil {
			return
		}
	}
	return
}
func (w *WorldBorder) read(rr io.Reader) (err error) {
	var tmp [8]byte
	if w.Action, err = ReadVarInt(rr); err != nil {
		return
	}
	if w.Action == 3 || w.Action == 1 {
		var tmp0 uint64
		if _, err = rr.Read(tmp[:8]); err != nil {
			return
		}
		tmp0 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
		w.OldRadius = math.Float64frombits(tmp0)
	}
	if w.Action == 3 || w.Action == 1 || w.Action == 0 {
		var tmp1 uint64
		if _, err = rr.Read(tmp[:8]); err != nil {
			return
		}
		tmp1 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
		w.NewRadius = math.Float64frombits(tmp1)
	}
	if w.Action == 3 || w.Action == 1 {
		if w.Speed, err = ReadVarLong(rr); err != nil {
			return
		}
	}
	if w.Action == 3 || w.Action == 2 {
		var tmp2 uint64
		if _, err = rr.Read(tmp[:8]); err != nil {
			return
		}
		tmp2 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
		w.X = math.Float64frombits(tmp2)
		var tmp3 uint64
		if _, err = rr.Read(tmp[:8]); err != nil {
			return
		}
		tmp3 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
		w.Z = math.Float64frombits(tmp3)
	}
	if w.Action == 3 {
		if w.PortalBoundary, err = ReadVarInt(rr); err != nil {
			return
		}
	}
	if w.Action == 3 || w.Action == 4 {
		if w.WarningTime, err = ReadVarInt(rr); err != nil {
			return
		}
	}
	if w.Action == 3 || w.Action == 5 {
		if w.WarningBlocks, err = ReadVarInt(rr); err != nil {
			return
		}
	}
	return
}

func (c *Camera) id() int { return 0x39 }
func (c *Camera) write(ww io.Writer) (err error) {
	if err = WriteVarInt(ww, c.TargetID); err != nil {
		return
	}
	return
}
func (c *Camera) read(rr io.Reader) (err error) {
	if c.TargetID, err = ReadVarInt(rr); err != nil {
		return
	}
	return
}

func (s *SetCurrentHotbarSlot) id() int { return 0x3A }
func (s *SetCurrentHotbarSlot) write(ww io.Writer) (err error) {
	var tmp [1]byte
	tmp[0] = byte(s.Slot >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	return
}
func (s *SetCurrentHotbarSlot) read(rr io.Reader) (err error) {
	var tmp [1]byte
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	s.Slot = (byte(tmp[0]) << 0)
	return
}

func (s *ScoreboardDisplay) id() int { return 0x3B }
func (s *ScoreboardDisplay) write(ww io.Writer) (err error) {
	var tmp [1]byte
	tmp[0] = byte(s.Position >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if err = WriteString(ww, s.Name); err != nil {
		return
	}
	return
}
func (s *ScoreboardDisplay) read(rr io.Reader) (err error) {
	var tmp [1]byte
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	s.Position = (byte(tmp[0]) << 0)
	if s.Name, err = ReadString(rr); err != nil {
		return
	}
	return
}

func (e *EntityMetadata) id() int { return 0x3C }
func (e *EntityMetadata) write(ww io.Writer) (err error) {
	if err = WriteVarInt(ww, e.EntityID); err != nil {
		return
	}
	if err = writeMetadata(ww, e.Metadata); err != nil {
		return
	}
	return
}
func (e *EntityMetadata) read(rr io.Reader) (err error) {
	if e.EntityID, err = ReadVarInt(rr); err != nil {
		return
	}
	if e.Metadata, err = readMetadata(rr); err != nil {
		return
	}
	return
}

func (e *EntityAttach) id() int { return 0x3D }
func (e *EntityAttach) write(ww io.Writer) (err error) {
	var tmp [4]byte
	tmp[0] = byte(e.EntityID >> 24)
	tmp[1] = byte(e.EntityID >> 16)
	tmp[2] = byte(e.EntityID >> 8)
	tmp[3] = byte(e.EntityID >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(e.Vehicle >> 24)
	tmp[1] = byte(e.Vehicle >> 16)
	tmp[2] = byte(e.Vehicle >> 8)
	tmp[3] = byte(e.Vehicle >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	return
}
func (e *EntityAttach) read(rr io.Reader) (err error) {
	var tmp [4]byte
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	e.EntityID = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	e.Vehicle = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	return
}

func (e *EntityVelocity) id() int { return 0x3E }
func (e *EntityVelocity) write(ww io.Writer) (err error) {
	var tmp [2]byte
	if err = WriteVarInt(ww, e.EntityID); err != nil {
		return
	}
	tmp[0] = byte(e.VelocityX >> 8)
	tmp[1] = byte(e.VelocityX >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	tmp[0] = byte(e.VelocityY >> 8)
	tmp[1] = byte(e.VelocityY >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	tmp[0] = byte(e.VelocityZ >> 8)
	tmp[1] = byte(e.VelocityZ >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	return
}
func (e *EntityVelocity) read(rr io.Reader) (err error) {
	var tmp [2]byte
	if e.EntityID, err = ReadVarInt(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	e.VelocityX = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	e.VelocityY = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	e.VelocityZ = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	return
}

func (e *EntityEquipment) id() int { return 0x3F }
func (e *EntityEquipment) write(ww io.Writer) (err error) {
	if err = WriteVarInt(ww, e.EntityID); err != nil {
		return
	}
	if err = WriteVarInt(ww, e.Slot); err != nil {
		return
	}
	if err = e.Item.Serialize(ww); err != nil {
		return
	}
	return
}
func (e *EntityEquipment) read(rr io.Reader) (err error) {
	if e.EntityID, err = ReadVarInt(rr); err != nil {
		return
	}
	if e.Slot, err = ReadVarInt(rr); err != nil {
		return
	}
	if err = e.Item.Deserialize(rr); err != nil {
		return
	}
	return
}

func (s *SetExperience) id() int { return 0x40 }
func (s *SetExperience) write(ww io.Writer) (err error) {
	var tmp [4]byte
	tmp0 := math.Float32bits(s.ExperienceBar)
	tmp[0] = byte(tmp0 >> 24)
	tmp[1] = byte(tmp0 >> 16)
	tmp[2] = byte(tmp0 >> 8)
	tmp[3] = byte(tmp0 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	if err = WriteVarInt(ww, s.Level); err != nil {
		return
	}
	if err = WriteVarInt(ww, s.TotalExperience); err != nil {
		return
	}
	return
}
func (s *SetExperience) read(rr io.Reader) (err error) {
	var tmp [4]byte
	var tmp0 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp0 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	s.ExperienceBar = math.Float32frombits(tmp0)
	if s.Level, err = ReadVarInt(rr); err != nil {
		return
	}
	if s.TotalExperience, err = ReadVarInt(rr); err != nil {
		return
	}
	return
}

func (u *UpdateHealth) id() int { return 0x41 }
func (u *UpdateHealth) write(ww io.Writer) (err error) {
	var tmp [4]byte
	tmp0 := math.Float32bits(u.Health)
	tmp[0] = byte(tmp0 >> 24)
	tmp[1] = byte(tmp0 >> 16)
	tmp[2] = byte(tmp0 >> 8)
	tmp[3] = byte(tmp0 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	if err = WriteVarInt(ww, u.Food); err != nil {
		return
	}
	tmp1 := math.Float32bits(u.FoodSaturation)
	tmp[0] = byte(tmp1 >> 24)
	tmp[1] = byte(tmp1 >> 16)
	tmp[2] = byte(tmp1 >> 8)
	tmp[3] = byte(tmp1 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	return
}
func (u *UpdateHealth) read(rr io.Reader) (err error) {
	var tmp [4]byte
	var tmp0 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp0 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	u.Health = math.Float32frombits(tmp0)
	if u.Food, err = ReadVarInt(rr); err != nil {
		return
	}
	var tmp1 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp1 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	u.FoodSaturation = math.Float32frombits(tmp1)
	return
}

func (s *ScoreboardObjective) id() int { return 0x42 }
func (s *ScoreboardObjective) write(ww io.Writer) (err error) {
	var tmp [1]byte
	if err = WriteString(ww, s.Name); err != nil {
		return
	}
	tmp[0] = byte(s.Mode >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if s.Mode == 0 || s.Mode == 2 {
		if err = WriteString(ww, s.Value); err != nil {
			return
		}
		if err = WriteString(ww, s.Type); err != nil {
			return
		}
	}
	return
}
func (s *ScoreboardObjective) read(rr io.Reader) (err error) {
	var tmp [1]byte
	if s.Name, err = ReadString(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	s.Mode = (byte(tmp[0]) << 0)
	if s.Mode == 0 || s.Mode == 2 {
		if s.Value, err = ReadString(rr); err != nil {
			return
		}
		if s.Type, err = ReadString(rr); err != nil {
			return
		}
	}
	return
}

func (s *SetPassengers) id() int { return 0x43 }
func (s *SetPassengers) write(ww io.Writer) (err error) {
	if err = WriteVarInt(ww, s.EntityID); err != nil {
		return
	}
	if err = WriteVarInt(ww, VarInt(len(s.Passengers))); err != nil {
		return
	}
	for tmp0 := range s.Passengers {
		if err = WriteVarInt(ww, s.Passengers[tmp0]); err != nil {
			return
		}
	}
	return
}
func (s *SetPassengers) read(rr io.Reader) (err error) {
	if s.EntityID, err = ReadVarInt(rr); err != nil {
		return
	}
	var tmp0 VarInt
	if tmp0, err = ReadVarInt(rr); err != nil {
		return
	}
	if tmp0 > math.MaxInt16 {
		return fmt.Errorf("array larger than max value: %d > %d", tmp0, math.MaxInt16)
	}
	if tmp0 < 0 {
		return fmt.Errorf("negative array size: %d < 0", tmp0)
	}
	s.Passengers = make([]VarInt, tmp0)
	for tmp1 := range s.Passengers {
		if s.Passengers[tmp1], err = ReadVarInt(rr); err != nil {
			return
		}
	}
	return
}

func (t *Teams) id() int { return 0x44 }
func (t *Teams) write(ww io.Writer) (err error) {
	var tmp [1]byte
	if err = WriteString(ww, t.Name); err != nil {
		return
	}
	tmp[0] = byte(t.Mode >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if t.Mode == 0 || t.Mode == 2 {
		if err = WriteString(ww, t.DisplayName); err != nil {
			return
		}
		if err = WriteString(ww, t.Prefix); err != nil {
			return
		}
		if err = WriteString(ww, t.Suffix); err != nil {
			return
		}
		tmp[0] = byte(t.Flags >> 0)
		if _, err = ww.Write(tmp[:1]); err != nil {
			return
		}
		if err = WriteString(ww, t.NameTagVisibility); err != nil {
			return
		}
		if err = WriteString(ww, t.CollisionRule); err != nil {
			return
		}
		tmp[0] = byte(t.Color >> 0)
		if _, err = ww.Write(tmp[:1]); err != nil {
			return
		}
	}
	if t.Mode == 0 || t.Mode == 3 || t.Mode == 4 {
		if err = WriteVarInt(ww, VarInt(len(t.Players))); err != nil {
			return
		}
		for tmp0 := range t.Players {
			if err = WriteString(ww, t.Players[tmp0]); err != nil {
				return
			}
		}
	}
	return
}
func (t *Teams) read(rr io.Reader) (err error) {
	var tmp [1]byte
	if t.Name, err = ReadString(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	t.Mode = (byte(tmp[0]) << 0)
	if t.Mode == 0 || t.Mode == 2 {
		if t.DisplayName, err = ReadString(rr); err != nil {
			return
		}
		if t.Prefix, err = ReadString(rr); err != nil {
			return
		}
		if t.Suffix, err = ReadString(rr); err != nil {
			return
		}
		if _, err = rr.Read(tmp[:1]); err != nil {
			return
		}
		t.Flags = (byte(tmp[0]) << 0)
		if t.NameTagVisibility, err = ReadString(rr); err != nil {
			return
		}
		if t.CollisionRule, err = ReadString(rr); err != nil {
			return
		}
		if _, err = rr.Read(tmp[:1]); err != nil {
			return
		}
		t.Color = (byte(tmp[0]) << 0)
	}
	if t.Mode == 0 || t.Mode == 3 || t.Mode == 4 {
		var tmp0 VarInt
		if tmp0, err = ReadVarInt(rr); err != nil {
			return
		}
		if tmp0 > math.MaxInt16 {
			return fmt.Errorf("array larger than max value: %d > %d", tmp0, math.MaxInt16)
		}
		if tmp0 < 0 {
			return fmt.Errorf("negative array size: %d < 0", tmp0)
		}
		t.Players = make([]string, tmp0)
		for tmp1 := range t.Players {
			if t.Players[tmp1], err = ReadString(rr); err != nil {
				return
			}
		}
	}
	return
}

func (u *UpdateScore) id() int { return 0x45 }
func (u *UpdateScore) write(ww io.Writer) (err error) {
	var tmp [1]byte
	if err = WriteString(ww, u.Name); err != nil {
		return
	}
	tmp[0] = byte(u.Action >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if err = WriteString(ww, u.ObjectName); err != nil {
		return
	}
	if u.Action != 1 {
		if err = WriteVarInt(ww, u.Value); err != nil {
			return
		}
	}
	return
}
func (u *UpdateScore) read(rr io.Reader) (err error) {
	var tmp [1]byte
	if u.Name, err = ReadString(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	u.Action = (byte(tmp[0]) << 0)
	if u.ObjectName, err = ReadString(rr); err != nil {
		return
	}
	if u.Action != 1 {
		if u.Value, err = ReadVarInt(rr); err != nil {
			return
		}
	}
	return
}

func (s *SpawnPosition) id() int { return 0x46 }
func (s *SpawnPosition) write(ww io.Writer) (err error) {
	var tmp [8]byte
	tmp[0] = byte(s.Location >> 56)
	tmp[1] = byte(s.Location >> 48)
	tmp[2] = byte(s.Location >> 40)
	tmp[3] = byte(s.Location >> 32)
	tmp[4] = byte(s.Location >> 24)
	tmp[5] = byte(s.Location >> 16)
	tmp[6] = byte(s.Location >> 8)
	tmp[7] = byte(s.Location >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	return
}
func (s *SpawnPosition) read(rr io.Reader) (err error) {
	var tmp [8]byte
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	s.Location = (Position(tmp[7]) << 0) | (Position(tmp[6]) << 8) | (Position(tmp[5]) << 16) | (Position(tmp[4]) << 24) | (Position(tmp[3]) << 32) | (Position(tmp[2]) << 40) | (Position(tmp[1]) << 48) | (Position(tmp[0]) << 56)
	return
}

func (t *TimeUpdate) id() int { return 0x47 }
func (t *TimeUpdate) write(ww io.Writer) (err error) {
	var tmp [8]byte
	tmp[0] = byte(t.WorldAge >> 56)
	tmp[1] = byte(t.WorldAge >> 48)
	tmp[2] = byte(t.WorldAge >> 40)
	tmp[3] = byte(t.WorldAge >> 32)
	tmp[4] = byte(t.WorldAge >> 24)
	tmp[5] = byte(t.WorldAge >> 16)
	tmp[6] = byte(t.WorldAge >> 8)
	tmp[7] = byte(t.WorldAge >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp[0] = byte(t.TimeOfDay >> 56)
	tmp[1] = byte(t.TimeOfDay >> 48)
	tmp[2] = byte(t.TimeOfDay >> 40)
	tmp[3] = byte(t.TimeOfDay >> 32)
	tmp[4] = byte(t.TimeOfDay >> 24)
	tmp[5] = byte(t.TimeOfDay >> 16)
	tmp[6] = byte(t.TimeOfDay >> 8)
	tmp[7] = byte(t.TimeOfDay >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	return
}
func (t *TimeUpdate) read(rr io.Reader) (err error) {
	var tmp [8]byte
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	t.WorldAge = int64((uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56))
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	t.TimeOfDay = int64((uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56))
	return
}

func (t *Title) id() int { return 0x48 }
func (t *Title) write(ww io.Writer) (err error) {
	var tmp [4]byte
	if err = WriteVarInt(ww, t.Action); err != nil {
		return
	}
	if t.Action == 0 {
		var tmp0 []byte
		if tmp0, err = json.Marshal(&t.Title); err != nil {
			return
		}
		tmp1 := string(tmp0)
		if err = WriteString(ww, tmp1); err != nil {
			return
		}
	}
	if t.Action == 1 {
		var tmp2 []byte
		if tmp2, err = json.Marshal(&t.SubTitle); err != nil {
			return
		}
		tmp3 := string(tmp2)
		if err = WriteString(ww, tmp3); err != nil {
			return
		}
	}
	if t.Action == 2 {
		var tmp4 []byte
		if tmp4, err = json.Marshal(&t.ActionBar); err != nil {
			return
		}
		tmp5 := string(tmp4)
		if err = WriteString(ww, tmp5); err != nil {
			return
		}
	}
	if t.Action == 3 {
		tmp[0] = byte(t.FadeIn >> 24)
		tmp[1] = byte(t.FadeIn >> 16)
		tmp[2] = byte(t.FadeIn >> 8)
		tmp[3] = byte(t.FadeIn >> 0)
		if _, err = ww.Write(tmp[:4]); err != nil {
			return
		}
		tmp[0] = byte(t.FadeStay >> 24)
		tmp[1] = byte(t.FadeStay >> 16)
		tmp[2] = byte(t.FadeStay >> 8)
		tmp[3] = byte(t.FadeStay >> 0)
		if _, err = ww.Write(tmp[:4]); err != nil {
			return
		}
		tmp[0] = byte(t.FadeOut >> 24)
		tmp[1] = byte(t.FadeOut >> 16)
		tmp[2] = byte(t.FadeOut >> 8)
		tmp[3] = byte(t.FadeOut >> 0)
		if _, err = ww.Write(tmp[:4]); err != nil {
			return
		}
	}
	return
}
func (t *Title) read(rr io.Reader) (err error) {
	var tmp [4]byte
	if t.Action, err = ReadVarInt(rr); err != nil {
		return
	}
	if t.Action == 0 {
		var tmp0 string
		if tmp0, err = ReadString(rr); err != nil {
			return err
		}
		if err = json.Unmarshal([]byte(tmp0), &t.Title); err != nil {
			return
		}
	}
	if t.Action == 1 {
		var tmp1 string
		if tmp1, err = ReadString(rr); err != nil {
			return err
		}
		if err = json.Unmarshal([]byte(tmp1), &t.SubTitle); err != nil {
			return
		}
	}
	if t.Action == 2 {
		var tmp2 string
		if tmp2, err = ReadString(rr); err != nil {
			return err
		}
		if err = json.Unmarshal([]byte(tmp2), &t.ActionBar); err != nil {
			return
		}
	}
	if t.Action == 3 {
		if _, err = rr.Read(tmp[:4]); err != nil {
			return
		}
		t.FadeIn = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
		if _, err = rr.Read(tmp[:4]); err != nil {
			return
		}
		t.FadeStay = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
		if _, err = rr.Read(tmp[:4]); err != nil {
			return
		}
		t.FadeOut = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	}
	return
}

func (s *SoundEffect) id() int { return 0x49 }
func (s *SoundEffect) write(ww io.Writer) (err error) {
	var tmp [4]byte
	if err = WriteVarInt(ww, s.SoundID); err != nil {
		return
	}
	if err = WriteVarInt(ww, s.Category); err != nil {
		return
	}
	tmp[0] = byte(s.X >> 24)
	tmp[1] = byte(s.X >> 16)
	tmp[2] = byte(s.X >> 8)
	tmp[3] = byte(s.X >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(s.Y >> 24)
	tmp[1] = byte(s.Y >> 16)
	tmp[2] = byte(s.Y >> 8)
	tmp[3] = byte(s.Y >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(s.Z >> 24)
	tmp[1] = byte(s.Z >> 16)
	tmp[2] = byte(s.Z >> 8)
	tmp[3] = byte(s.Z >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp0 := math.Float32bits(s.Volume)
	tmp[0] = byte(tmp0 >> 24)
	tmp[1] = byte(tmp0 >> 16)
	tmp[2] = byte(tmp0 >> 8)
	tmp[3] = byte(tmp0 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp1 := math.Float32bits(s.Pitch)
	tmp[0] = byte(tmp1 >> 24)
	tmp[1] = byte(tmp1 >> 16)
	tmp[2] = byte(tmp1 >> 8)
	tmp[3] = byte(tmp1 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	return
}
func (s *SoundEffect) read(rr io.Reader) (err error) {
	var tmp [4]byte
	if s.SoundID, err = ReadVarInt(rr); err != nil {
		return
	}
	if s.Category, err = ReadVarInt(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	s.X = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	s.Y = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	s.Z = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	var tmp0 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp0 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	s.Volume = math.Float32frombits(tmp0)
	var tmp1 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp1 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	s.Pitch = math.Float32frombits(tmp1)
	return
}

func (p *PlayerListHeaderFooter) id() int { return 0x4A }
func (p *PlayerListHeaderFooter) write(ww io.Writer) (err error) {
	var tmp0 []byte
	if tmp0, err = json.Marshal(&p.Header); err != nil {
		return
	}
	tmp1 := string(tmp0)
	if err = WriteString(ww, tmp1); err != nil {
		return
	}
	var tmp2 []byte
	if tmp2, err = json.Marshal(&p.Footer); err != nil {
		return
	}
	tmp3 := string(tmp2)
	if err = WriteString(ww, tmp3); err != nil {
		return
	}
	return
}
func (p *PlayerListHeaderFooter) read(rr io.Reader) (err error) {
	var tmp0 string
	if tmp0, err = ReadString(rr); err != nil {
		return err
	}
	if err = json.Unmarshal([]byte(tmp0), &p.Header); err != nil {
		return
	}
	var tmp1 string
	if tmp1, err = ReadString(rr); err != nil {
		return err
	}
	if err = json.Unmarshal([]byte(tmp1), &p.Footer); err != nil {
		return
	}
	return
}

func (c *CollectItem) id() int { return 0x4B }
func (c *CollectItem) write(ww io.Writer) (err error) {
	if err = WriteVarInt(ww, c.CollectedEntityID); err != nil {
		return
	}
	if err = WriteVarInt(ww, c.CollectorEntityID); err != nil {
		return
	}
	if err = WriteVarInt(ww, c.Count); err != nil {
		return
	}
	return
}
func (c *CollectItem) read(rr io.Reader) (err error) {
	if c.CollectedEntityID, err = ReadVarInt(rr); err != nil {
		return
	}
	if c.CollectorEntityID, err = ReadVarInt(rr); err != nil {
		return
	}
	if c.Count, err = ReadVarInt(rr); err != nil {
		return
	}
	return
}

func (e *EntityTeleport) id() int { return 0x4C }
func (e *EntityTeleport) write(ww io.Writer) (err error) {
	var tmp [8]byte
	if err = WriteVarInt(ww, e.EntityID); err != nil {
		return
	}
	tmp0 := math.Float64bits(e.X)
	tmp[0] = byte(tmp0 >> 56)
	tmp[1] = byte(tmp0 >> 48)
	tmp[2] = byte(tmp0 >> 40)
	tmp[3] = byte(tmp0 >> 32)
	tmp[4] = byte(tmp0 >> 24)
	tmp[5] = byte(tmp0 >> 16)
	tmp[6] = byte(tmp0 >> 8)
	tmp[7] = byte(tmp0 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp1 := math.Float64bits(e.Y)
	tmp[0] = byte(tmp1 >> 56)
	tmp[1] = byte(tmp1 >> 48)
	tmp[2] = byte(tmp1 >> 40)
	tmp[3] = byte(tmp1 >> 32)
	tmp[4] = byte(tmp1 >> 24)
	tmp[5] = byte(tmp1 >> 16)
	tmp[6] = byte(tmp1 >> 8)
	tmp[7] = byte(tmp1 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp2 := math.Float64bits(e.Z)
	tmp[0] = byte(tmp2 >> 56)
	tmp[1] = byte(tmp2 >> 48)
	tmp[2] = byte(tmp2 >> 40)
	tmp[3] = byte(tmp2 >> 32)
	tmp[4] = byte(tmp2 >> 24)
	tmp[5] = byte(tmp2 >> 16)
	tmp[6] = byte(tmp2 >> 8)
	tmp[7] = byte(tmp2 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp[0] = byte(e.Yaw >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(e.Pitch >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if err = WriteBool(ww, e.OnGround); err != nil {
		return
	}
	return
}
func (e *EntityTeleport) read(rr io.Reader) (err error) {
	var tmp [8]byte
	if e.EntityID, err = ReadVarInt(rr); err != nil {
		return
	}
	var tmp0 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp0 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	e.X = math.Float64frombits(tmp0)
	var tmp1 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp1 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	e.Y = math.Float64frombits(tmp1)
	var tmp2 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp2 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	e.Z = math.Float64frombits(tmp2)
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	e.Yaw = int8((uint8(tmp[0]) << 0))
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	e.Pitch = int8((uint8(tmp[0]) << 0))
	if e.OnGround, err = ReadBool(rr); err != nil {
		return
	}
	return
}

func (a *Advancements) id() int { return 0x4D }
func (a *Advancements) write(ww io.Writer) (err error) {
	var tmp [8]byte
	if err = WriteBool(ww, a.Reset); err != nil {
		return
	}
	if err = WriteVarInt(ww, VarInt(len(a.Advancements))); err != nil {
		return
	}
	for tmp0 := range a.Advancements {
		if err = WriteString(ww, a.Advancements[tmp0].Key); err != nil {
			return
		}
		if err = WriteBool(ww, a.Advancements[tmp0].HasParent); err != nil {
			return
		}
		if a.Advancements[tmp0].HasParent == true {
			if err = WriteString(ww, a.Advancements[tmp0].Parent); err != nil {
				return
			}
		}
		if err = WriteBool(ww, a.Advancements[tmp0].HasDisplay); err != nil {
			return
		}
		if a.Advancements[tmp0].HasDisplay == true {
			var tmp1 []byte
			if tmp1, err = json.Marshal(&a.Advancements[tmp0].Display.Title); err != nil {
				return
			}
			tmp2 := string(tmp1)
			if err = WriteString(ww, tmp2); err != nil {
				return
			}
			var tmp3 []byte
			if tmp3, err = json.Marshal(&a.Advancements[tmp0].Display.Description); err != nil {
				return
			}
			tmp4 := string(tmp3)
			if err = WriteString(ww, tmp4); err != nil {
				return
			}
			if err = a.Advancements[tmp0].Display.Item.Serialize(ww); err != nil {
				return
			}
			if err = WriteVarInt(ww, a.Advancements[tmp0].Display.FrameType); err != nil {
				return
			}
			tmp[0] = byte(a.Advancements[tmp0].Display.Flags >> 24)
			tmp[1] = byte(a.Advancements[tmp0].Display.Flags >> 16)
			tmp[2] = byte(a.Advancements[tmp0].Display.Flags >> 8)
			tmp[3] = byte(a.Advancements[tmp0].Display.Flags >> 0)
			if _, err = ww.Write(tmp[:4]); err != nil {
				return
			}
			if a.Advancements[tmp0].Display.Flags&1 == 1 {
				if err = WriteString(ww, a.Advancements[tmp0].Display.BackgroundTexture); err != nil {
					return
				}
			}
			tmp5 := math.Float32bits(a.Advancements[tmp0].Display.X)
			tmp[0] = byte(tmp5 >> 24)
			tmp[1] = byte(tmp5 >> 16)
			tmp[2] = byte(tmp5 >> 8)
			tmp[3] = byte(tmp5 >> 0)
			if _, err = ww.Write(tmp[:4]); err != nil {
				return
			}
			tmp6 := math.Float32bits(a.Advancements[tmp0].Display.Y)
			tmp[0] = byte(tmp6 >> 24)
			tmp[1] = byte(tmp6 >> 16)
			tmp[2] = byte(tmp6 >> 8)
			tmp[3] = byte(tmp6 >> 0)
			if _, err = ww.Write(tmp[:4]); err != nil {
				return
			}
		}
		if err = WriteVarInt(ww, VarInt(len(a.Advancements[tmp0].Criteria))); err != nil {
			return
		}
		for tmp7 := range a.Advancements[tmp0].Criteria {
			if err = WriteString(ww, a.Advancements[tmp0].Criteria[tmp7]); err != nil {
				return
			}
		}
		if err = WriteVarInt(ww, VarInt(len(a.Advancements[tmp0].Requirements))); err != nil {
			return
		}
		for tmp8 := range a.Advancements[tmp0].Requirements {
			if err = WriteVarInt(ww, VarInt(len(a.Advancements[tmp0].Requirements[tmp8].Criteria))); err != nil {
				return
			}
			for tmp9 := range a.Advancements[tmp0].Requirements[tmp8].Criteria {
				if err = WriteString(ww, a.Advancements[tmp0].Requirements[tmp8].Criteria[tmp9]); err != nil {
					return
				}
			}
		}
	}
	if err = WriteVarInt(ww, VarInt(len(a.Remove))); err != nil {
		return
	}
	for tmp10 := range a.Remove {
		if err = WriteString(ww, a.Remove[tmp10]); err != nil {
			return
		}
	}
	if err = WriteVarInt(ww, VarInt(len(a.Progress))); err != nil {
		return
	}
	for tmp11 := range a.Progress {
		if err = WriteString(ww, a.Progress[tmp11].Key); err != nil {
			return
		}
		if err = WriteVarInt(ww, VarInt(len(a.Progress[tmp11].Criteria))); err != nil {
			return
		}
		for tmp12 := range a.Progress[tmp11].Criteria {
			if err = WriteString(ww, a.Progress[tmp11].Criteria[tmp12].Key); err != nil {
				return
			}
			if err = WriteBool(ww, a.Progress[tmp11].Criteria[tmp12].Achieved); err != nil {
				return
			}
			if a.Progress[tmp11].Criteria[tmp12].Achieved == true {
				tmp[0] = byte(a.Progress[tmp11].Criteria[tmp12].AchievedTime >> 56)
				tmp[1] = byte(a.Progress[tmp11].Criteria[tmp12].AchievedTime >> 48)
				tmp[2] = byte(a.Progress[tmp11].Criteria[tmp12].AchievedTime >> 40)
				tmp[3] = byte(a.Progress[tmp11].Criteria[tmp12].AchievedTime >> 32)
				tmp[4] = byte(a.Progress[tmp11].Criteria[tmp12].AchievedTime >> 24)
				tmp[5] = byte(a.Progress[tmp11].Criteria[tmp12].AchievedTime >> 16)
				tmp[6] = byte(a.Progress[tmp11].Criteria[tmp12].AchievedTime >> 8)
				tmp[7] = byte(a.Progress[tmp11].Criteria[tmp12].AchievedTime >> 0)
				if _, err = ww.Write(tmp[:8]); err != nil {
					return
				}
			}
		}
	}
	return
}
func (a *Advancements) read(rr io.Reader) (err error) {
	var tmp [8]byte
	if a.Reset, err = ReadBool(rr); err != nil {
		return
	}
	var tmp0 VarInt
	if tmp0, err = ReadVarInt(rr); err != nil {
		return
	}
	if tmp0 > math.MaxInt16 {
		return fmt.Errorf("array larger than max value: %d > %d", tmp0, math.MaxInt16)
	}
	if tmp0 < 0 {
		return fmt.Errorf("negative array size: %d < 0", tmp0)
	}
	a.Advancements = make([]Advancement, tmp0)
	for tmp1 := range a.Advancements {
		if a.Advancements[tmp1].Key, err = ReadString(rr); err != nil {
			return
		}
		if a.Advancements[tmp1].HasParent, err = ReadBool(rr); err != nil {
			return
		}
		if a.Advancements[tmp1].HasParent == true {
			if a.Advancements[tmp1].Parent, err = ReadString(rr); err != nil {
				return
			}
		}
		if a.Advancements[tmp1].HasDisplay, err = ReadBool(rr); err != nil {
			return
		}
		if a.Advancements[tmp1].HasDisplay == true {
			var tmp2 string
			if tmp2, err = ReadString(rr); err != nil {
				return err
			}
			if err = json.Unmarshal([]byte(tmp2), &a.Advancements[tmp1].Display.Title); err != nil {
				return
			}
			var tmp3 string
			if tmp3, err = ReadString(rr); err != nil {
				return err
			}
			if err = json.Unmarshal([]byte(tmp3), &a.Advancements[tmp1].Display.Description); err != nil {
				return
			}
			if err = a.Advancements[tmp1].Display.Item.Deserialize(rr); err != nil {
				return
			}
			if a.Advancements[tmp1].Display.FrameType, err = ReadVarInt(rr); err != nil {
				return
			}
			if _, err = rr.Read(tmp[:4]); err != nil {
				return
			}
			a.Advancements[tmp1].Display.Flags = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
			if a.Advancements[tmp1].Display.Flags&1 == 1 {
				if a.Advancements[tmp1].Display.BackgroundTexture, err = ReadString(rr); err != nil {
					return
				}
			}
			var tmp4 uint32
			if _, err = rr.Read(tmp[:4]); err != nil {
				return
			}
			tmp4 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
			a.Advancements[tmp1].Display.X = math.Float32frombits(tmp4)
			var tmp5 uint32
			if _, err = rr.Read(tmp[:4]); err != nil {
				return
			}
			tmp5 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
			a.Advancements[tmp1].Display.Y = math.Float32frombits(tmp5)
		}
		var tmp6 VarInt
		if tmp6, err = ReadVarInt(rr); err != nil {
			return
		}
		if tmp6 > math.MaxInt16 {
			return fmt.Errorf("array larger than max value: %d > %d", tmp6, math.MaxInt16)
		}
		if tmp6 < 0 {
			return fmt.Errorf("negative array size: %d < 0", tmp6)
		}
		a.Advancements[tmp1].Criteria = make([]string, tmp6)
		for tmp7 := range a.Advancements[tmp1].Criteria {
			if a.Advancements[tmp1].Criteria[tmp7], err = ReadString(rr); err != nil {
				return
			}
		}
		var tmp8 VarInt
		if tmp8, err = ReadVarInt(rr); err != nil {
			return
		}
		if tmp8 > math.MaxInt16 {
			return fmt.Errorf("array larger than max value: %d > %d", tmp8, math.MaxInt16)
		}
		if tmp8 < 0 {
			return fmt.Errorf("negative array size: %d < 0", tmp8)
		}
		a.Advancements[tmp1].Requirements = make([]Requirement, tmp8)
		for tmp9 := range a.Advancements[tmp1].Requirements {
			var tmp10 VarInt
			if tmp10, err = ReadVarInt(rr); err != nil {
				return
			}
			if tmp10 > math.MaxInt16 {
				return fmt.Errorf("array larger than max value: %d > %d", tmp10, math.MaxInt16)
			}
			if tmp10 < 0 {
				return fmt.Errorf("negative array size: %d < 0", tmp10)
			}
			a.Advancements[tmp1].Requirements[tmp9].Criteria = make([]string, tmp10)
			for tmp11 := range a.Advancements[tmp1].Requirements[tmp9].Criteria {
				if a.Advancements[tmp1].Requirements[tmp9].Criteria[tmp11], err = ReadString(rr); err != nil {
					return
				}
			}
		}
	}
	var tmp12 VarInt
	if tmp12, err = ReadVarInt(rr); err != nil {
		return
	}
	if tmp12 > math.MaxInt16 {
		return fmt.Errorf("array larger than max value: %d > %d", tmp12, math.MaxInt16)
	}
	if tmp12 < 0 {
		return fmt.Errorf("negative array size: %d < 0", tmp12)
	}
	a.Remove = make([]string, tmp12)
	for tmp13 := range a.Remove {
		if a.Remove[tmp13], err = ReadString(rr); err != nil {
			return
		}
	}
	var tmp14 VarInt
	if tmp14, err = ReadVarInt(rr); err != nil {
		return
	}
	if tmp14 > math.MaxInt16 {
		return fmt.Errorf("array larger than max value: %d > %d", tmp14, math.MaxInt16)
	}
	if tmp14 < 0 {
		return fmt.Errorf("negative array size: %d < 0", tmp14)
	}
	a.Progress = make([]Progress, tmp14)
	for tmp15 := range a.Progress {
		if a.Progress[tmp15].Key, err = ReadString(rr); err != nil {
			return
		}
		var tmp16 VarInt
		if tmp16, err = ReadVarInt(rr); err != nil {
			return
		}
		if tmp16 > math.MaxInt16 {
			return fmt.Errorf("array larger than max value: %d > %d", tmp16, math.MaxInt16)
		}
		if tmp16 < 0 {
			return fmt.Errorf("negative array size: %d < 0", tmp16)
		}
		a.Progress[tmp15].Criteria = make([]CriterionProgress, tmp16)
		for tmp17 := range a.Progress[tmp15].Criteria {
			if a.Progress[tmp15].Criteria[tmp17].Key, err = ReadString(rr); err != nil {
				return
			}
			if a.Progress[tmp15].Criteria[tmp17].Achieved, err = ReadBool(rr); err != nil {
				return
			}
			if a.Progress[tmp15].Criteria[tmp17].Achieved == true {
				if _, err = rr.Read(tmp[:8]); err != nil {
					return
				}
				a.Progress[tmp15].Criteria[tmp17].AchievedTime = int64((uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56))
			}
		}
	}
	return
}

func (e *EntityProperties) id() int { return 0x4E }
func (e *EntityProperties) write(ww io.Writer) (err error) {
	var tmp [8]byte
	if err = WriteVarInt(ww, e.EntityID); err != nil {
		return
	}
	tmp[0] = byte(int32(len(e.Properties)) >> 24)
	tmp[1] = byte(int32(len(e.Properties)) >> 16)
	tmp[2] = byte(int32(len(e.Properties)) >> 8)
	tmp[3] = byte(int32(len(e.Properties)) >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	for tmp0 := range e.Properties {
		if err = WriteString(ww, e.Properties[tmp0].Key); err != nil {
			return
		}
		tmp1 := math.Float64bits(e.Properties[tmp0].Value)
		tmp[0] = byte(tmp1 >> 56)
		tmp[1] = byte(tmp1 >> 48)
		tmp[2] = byte(tmp1 >> 40)
		tmp[3] = byte(tmp1 >> 32)
		tmp[4] = byte(tmp1 >> 24)
		tmp[5] = byte(tmp1 >> 16)
		tmp[6] = byte(tmp1 >> 8)
		tmp[7] = byte(tmp1 >> 0)
		if _, err = ww.Write(tmp[:8]); err != nil {
			return
		}
		if err = WriteVarInt(ww, VarInt(len(e.Properties[tmp0].Modifiers))); err != nil {
			return
		}
		for tmp2 := range e.Properties[tmp0].Modifiers {
			if err = e.Properties[tmp0].Modifiers[tmp2].UUID.Serialize(ww); err != nil {
				return
			}
			tmp3 := math.Float64bits(e.Properties[tmp0].Modifiers[tmp2].Amount)
			tmp[0] = byte(tmp3 >> 56)
			tmp[1] = byte(tmp3 >> 48)
			tmp[2] = byte(tmp3 >> 40)
			tmp[3] = byte(tmp3 >> 32)
			tmp[4] = byte(tmp3 >> 24)
			tmp[5] = byte(tmp3 >> 16)
			tmp[6] = byte(tmp3 >> 8)
			tmp[7] = byte(tmp3 >> 0)
			if _, err = ww.Write(tmp[:8]); err != nil {
				return
			}
			tmp[0] = byte(e.Properties[tmp0].Modifiers[tmp2].Operation >> 0)
			if _, err = ww.Write(tmp[:1]); err != nil {
				return
			}
		}
	}
	return
}
func (e *EntityProperties) read(rr io.Reader) (err error) {
	var tmp [8]byte
	if e.EntityID, err = ReadVarInt(rr); err != nil {
		return
	}
	var tmp0 int32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp0 = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if tmp0 > math.MaxInt16 {
		return fmt.Errorf("array larger than max value: %d > %d", tmp0, math.MaxInt16)
	}
	if tmp0 < 0 {
		return fmt.Errorf("negative array size: %d < 0", tmp0)
	}
	e.Properties = make([]EntityProperty, tmp0)
	for tmp1 := range e.Properties {
		if e.Properties[tmp1].Key, err = ReadString(rr); err != nil {
			return
		}
		var tmp2 uint64
		if _, err = rr.Read(tmp[:8]); err != nil {
			return
		}
		tmp2 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
		e.Properties[tmp1].Value = math.Float64frombits(tmp2)
		var tmp3 VarInt
		if tmp3, err = ReadVarInt(rr); err != nil {
			return
		}
		if tmp3 > math.MaxInt16 {
			return fmt.Errorf("array larger than max value: %d > %d", tmp3, math.MaxInt16)
		}
		if tmp3 < 0 {
			return fmt.Errorf("negative array size: %d < 0", tmp3)
		}
		e.Properties[tmp1].Modifiers = make([]PropertyModifier, tmp3)
		for tmp4 := range e.Properties[tmp1].Modifiers {
			if err = e.Properties[tmp1].Modifiers[tmp4].UUID.Deserialize(rr); err != nil {
				return
			}
			var tmp5 uint64
			if _, err = rr.Read(tmp[:8]); err != nil {
				return
			}
			tmp5 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
			e.Properties[tmp1].Modifiers[tmp4].Amount = math.Float64frombits(tmp5)
			if _, err = rr.Read(tmp[:1]); err != nil {
				return
			}
			e.Properties[tmp1].Modifiers[tmp4].Operation = int8((uint8(tmp[0]) << 0))
		}
	}
	return
}

func (e *EntityEffect) id() int { return 0x4F }
func (e *EntityEffect) write(ww io.Writer) (err error) {
	var tmp [1]byte
	if err = WriteVarInt(ww, e.EntityID); err != nil {
		return
	}
	tmp[0] = byte(e.EffectID >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(e.Amplifier >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if err = WriteVarInt(ww, e.Duration); err != nil {
		return
	}
	if err = WriteBool(ww, e.HideParticles); err != nil {
		return
	}
	return
}
func (e *EntityEffect) read(rr io.Reader) (err error) {
	var tmp [1]byte
	if e.EntityID, err = ReadVarInt(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	e.EffectID = int8((uint8(tmp[0]) << 0))
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	e.Amplifier = int8((uint8(tmp[0]) << 0))
	if e.Duration, err = ReadVarInt(rr); err != nil {
		return
	}
	if e.HideParticles, err = ReadBool(rr); err != nil {
		return
	}
	return
}

func init() {
	packetCreator[Play][clientbound][0x00] = func() Packet { return &SpawnObject{} }
	packetCreator[Play][clientbound][0x01] = func() Packet { return &SpawnExperienceOrb{} }
	packetCreator[Play][clientbound][0x02] = func() Packet { return &SpawnGlobalEntity{} }
	packetCreator[Play][clientbound][0x03] = func() Packet { return &SpawnMob{} }
	packetCreator[Play][clientbound][0x04] = func() Packet { return &SpawnPainting{} }
	packetCreator[Play][clientbound][0x05] = func() Packet { return &SpawnPlayer{} }
	packetCreator[Play][clientbound][0x06] = func() Packet { return &Animation{} }
	packetCreator[Play][clientbound][0x07] = func() Packet { return &Statistics{} }
	packetCreator[Play][clientbound][0x08] = func() Packet { return &BlockBreakAnimation{} }
	packetCreator[Play][clientbound][0x09] = func() Packet { return &UpdateBlockEntity{} }
	packetCreator[Play][clientbound][0x0A] = func() Packet { return &BlockAction{} }
	packetCreator[Play][clientbound][0x0B] = func() Packet { return &BlockChange{} }
	packetCreator[Play][clientbound][0x0C] = func() Packet { return &BossBar{} }
	packetCreator[Play][clientbound][0x0D] = func() Packet { return &ServerDifficulty{} }
	packetCreator[Play][clientbound][0x0E] = func() Packet { return &TabCompleteReply{} }
	packetCreator[Play][clientbound][0x0F] = func() Packet { return &ServerMessage{} }
	packetCreator[Play][clientbound][0x10] = func() Packet { return &MultiBlockChange{} }
	packetCreator[Play][clientbound][0x11] = func() Packet { return &ConfirmTransaction{} }
	packetCreator[Play][clientbound][0x12] = func() Packet { return &WindowClose{} }
	packetCreator[Play][clientbound][0x13] = func() Packet { return &WindowOpen{} }
	packetCreator[Play][clientbound][0x14] = func() Packet { return &WindowItems{} }
	packetCreator[Play][clientbound][0x15] = func() Packet { return &WindowProperty{} }
	packetCreator[Play][clientbound][0x16] = func() Packet { return &WindowSetSlot{} }
	packetCreator[Play][clientbound][0x17] = func() Packet { return &SetCooldown{} }
	packetCreator[Play][clientbound][0x18] = func() Packet { return &PluginMessageClientbound{} }
	packetCreator[Play][clientbound][0x19] = func() Packet { return &NamedSoundEffect{} }
	packetCreator[Play][clientbound][0x1A] = func() Packet { return &Disconnect{} }
	packetCreator[Play][clientbound][0x1B] = func() Packet { return &EntityAction{} }
	packetCreator[Play][clientbound][0x1C] = func() Packet { return &Explosion{} }
	packetCreator[Play][clientbound][0x1D] = func() Packet { return &ChunkUnload{} }
	packetCreator[Play][clientbound][0x1E] = func() Packet { return &ChangeGameState{} }
	packetCreator[Play][clientbound][0x1F] = func() Packet { return &KeepAliveClientbound{} }
	packetCreator[Play][clientbound][0x20] = func() Packet { return &ChunkData{} }
	packetCreator[Play][clientbound][0x21] = func() Packet { return &Effect{} }
	packetCreator[Play][clientbound][0x22] = func() Packet { return &Particle{} }
	packetCreator[Play][clientbound][0x23] = func() Packet { return &JoinGame{} }
	packetCreator[Play][clientbound][0x24] = func() Packet { return &Maps{} }
	packetCreator[Play][clientbound][0x25] = func() Packet { return &Entity{} }
	packetCreator[Play][clientbound][0x26] = func() Packet { return &EntityMove{} }
	packetCreator[Play][clientbound][0x27] = func() Packet { return &EntityLookAndMove{} }
	packetCreator[Play][clientbound][0x28] = func() Packet { return &EntityLook{} }
	packetCreator[Play][clientbound][0x29] = func() Packet { return &VebicleMoveClientbound{} }
	packetCreator[Play][clientbound][0x2A] = func() Packet { return &SignEditorOpen{} }
	packetCreator[Play][clientbound][0x2B] = func() Packet { return &CraftRecipeResponse{} }
	packetCreator[Play][clientbound][0x2C] = func() Packet { return &PlayerAbilities{} }
	packetCreator[Play][clientbound][0x2D] = func() Packet { return &CombatEvent{} }
	packetCreator[Play][clientbound][0x2E] = func() Packet { return &PlayerInfo{} }
	packetCreator[Play][clientbound][0x2F] = func() Packet { return &TeleportPlayer{} }
	packetCreator[Play][clientbound][0x30] = func() Packet { return &EntityUsedBed{} }
	packetCreator[Play][clientbound][0x31] = func() Packet { return &UnlockRecipes{} }
	packetCreator[Play][clientbound][0x32] = func() Packet { return &EntityDestroy{} }
	packetCreator[Play][clientbound][0x33] = func() Packet { return &EntityRemoveEffect{} }
	packetCreator[Play][clientbound][0x34] = func() Packet { return &ResourcePackSend{} }
	packetCreator[Play][clientbound][0x35] = func() Packet { return &Respawn{} }
	packetCreator[Play][clientbound][0x36] = func() Packet { return &EntityHeadLook{} }
	packetCreator[Play][clientbound][0x37] = func() Packet { return &SelectAdvancementTab{} }
	packetCreator[Play][clientbound][0x38] = func() Packet { return &WorldBorder{} }
	packetCreator[Play][clientbound][0x39] = func() Packet { return &Camera{} }
	packetCreator[Play][clientbound][0x3A] = func() Packet { return &SetCurrentHotbarSlot{} }
	packetCreator[Play][clientbound][0x3B] = func() Packet { return &ScoreboardDisplay{} }
	packetCreator[Play][clientbound][0x3C] = func() Packet { return &EntityMetadata{} }
	packetCreator[Play][clientbound][0x3D] = func() Packet { return &EntityAttach{} }
	packetCreator[Play][clientbound][0x3E] = func() Packet { return &EntityVelocity{} }
	packetCreator[Play][clientbound][0x3F] = func() Packet { return &EntityEquipment{} }
	packetCreator[Play][clientbound][0x40] = func() Packet { return &SetExperience{} }
	packetCreator[Play][clientbound][0x41] = func() Packet { return &UpdateHealth{} }
	packetCreator[Play][clientbound][0x42] = func() Packet { return &ScoreboardObjective{} }
	packetCreator[Play][clientbound][0x43] = func() Packet { return &SetPassengers{} }
	packetCreator[Play][clientbound][0x44] = func() Packet { return &Teams{} }
	packetCreator[Play][clientbound][0x45] = func() Packet { return &UpdateScore{} }
	packetCreator[Play][clientbound][0x46] = func() Packet { return &SpawnPosition{} }
	packetCreator[Play][clientbound][0x47] = func() Packet { return &TimeUpdate{} }
	packetCreator[Play][clientbound][0x48] = func() Packet { return &Title{} }
	packetCreator[Play][clientbound][0x49] = func() Packet { return &SoundEffect{} }
	packetCreator[Play][clientbound][0x4A] = func() Packet { return &PlayerListHeaderFooter{} }
	packetCreator[Play][clientbound][0x4B] = func() Packet { return &CollectItem{} }
	packetCreator[Play][clientbound][0x4C] = func() Packet { return &EntityTeleport{} }
	packetCreator[Play][clientbound][0x4D] = func() Packet { return &Advancements{} }
	packetCreator[Play][clientbound][0x4E] = func() Packet { return &EntityProperties{} }
	packetCreator[Play][clientbound][0x4F] = func() Packet { return &EntityEffect{} }
}
